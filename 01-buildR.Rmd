# Model setup with SWATBuildR

```{r}
print(paste("Code executed on", Sys.time()))
```

The OPTAIN project is using the COCOA approach [@schürz2022] and as such, needs to use the `SWATBuildR` package to build the SWAT+ model setup and calculate the connectivity between HRUs in the catchment. This chapter covers this process.

## BuildR Setup

We will need the following packages for this chapter:

```{r, libraries, message=FALSE}

# not loading most packages because they interfere with the `install_load` 
# functions of BuildR. this means I need to prefix everything with :: until
# Christoph turns BuildR into a proper package with proper scoping. 

# require(dplyr)
# require(ggplot2)
# require(mapview)
# require(sf)
# require(raster)
# require(terra)

require(magrittr)
require(raster)

# Common ggplot theme for simple features
sf_theme <- ggplot2::theme(axis.text.x=ggplot2::element_blank(),
        axis.ticks.x=ggplot2::element_blank(), 
        axis.text.y=ggplot2::element_blank(), 
        axis.ticks.y=ggplot2::element_blank()
        )
```

We will define the location of our project here, and give it a name:

```{r, projectpath}
project_path <- 'model_data/cs10_setup'
project_name <- 'optain-cs10'

# run the buildR?
run_code = FALSE

# load the BuildR
source('model_data/swat_buildR/init.R')
# Note the many "maskings" occuring here, dangerous!
```

## Processing input data

SWATBuildR reads input data, performs some checks on it, and saves it in a compatible format for subsequent calculations. Little documentation exists on the creation of these data sets. IF you have any information to add, feel free to do so!

### High-Resolution Digital Elevation Model (DEM)

The high-resolution DEM is the basis for calculation of water connectivity, among other things. Most of the documentation of the creation of the DEM for CS10 has been lost to the sands of time. All we know is that it is located here:

```{r, dempath}
dem_path <- "model_data/input/elevation/dtm3_ns_v5.tif"
```

```{r, plotdemraster, message=FALSE, fig.align = "center", fig.cap="CS10 Digital elevation model (DEM)."}
dem_rast <- raster::raster(dem_path)
plot(dem_rast)
```

To our knowledge, it has a 10 meter resolution. 1 meter resolution was available but there seems to have been issues with using it. It is definitely preferable to use the 1m DEM as certain important information can be lost with (max allowed resolution) of 10m.

![An example of a hydrologically effective landscape features being lost due to coarse DEM resolution. From [@schürz2022]](figures/1mdemvs10.png)

### Processing the Basin Boundary

The basin boundary has presumably been created using the defined outlet point of the catchment and the DEM. No more is currently known about this file other than that it is located here:

```{r, boundpath}
bound_path <- "model_data/input/shape/cs10_basin.shp"
```

```{r, watershedplot, message=FALSE, echo=T, eval=TRUE, fig.align='center', fig.cap="CS10 Basin, caclulated from the DEM."}
bound_sf <- sf::read_sf(bound_path)

basin <- ggplot2::ggplot(bound_sf) + ggplot2::geom_sf() + sf_theme

print(basin)
```

The following code and commentary is from version `1.5.14`, written by Christoph Schuerz.

BuildR recommends all layers to be in the same CRS, if we set `project_layer` to `FALSE`, it will throw an error when this is not the case:

> The input layers might be in different coordinate reference systems (CRS). It is recommended to project all layers to the same CRS and check them before using them as model inputs. The model setup process checks if the layer CRSs differ from the one of the basin boundary. By setting 'proj_layer \<- TRUE' the layer is projected if the CRS is different. If FALSE different CRS trigger an error.

```{r, projlayerbool}
project_layer <- TRUE
```

We read in and check the basin boundary and run some checks

```{r, checkbound, eval=run_code}
bound <- read_sf(bound_path) %>% select()
set_proj_crs(bound, data_path)
check_polygon_topology(layer = bound, data_path =  data_path, label = 'basin', 
                       n_feat = 1, checks = c(F,T,T,T,F,F,F,F))
```

### Processing the Land layer

Our land layer is located here:

```{r, landpath}
land_path <- "model_data/input/land/CS10_LU.shp"
```

Documentation on its creation does not exist.

```{r, maplanduse, message=F, echo=T, fig.align='center', fig.cap="Land use map of CS10 by Farm ID"}
lu_shp <- sf::read_sf(land_path)

lu_map <- ggplot2::ggplot(lu_shp) + ggplot2::geom_sf(ggplot2::aes(fill = type)) + sf_theme +
  ggplot2::theme(legend.position = "none")

print(lu_map)

```

We had an issue with the classification of the land uses. For the OPTAIN project, all agricultural fields must have a unique ID, and our land uses only had the ID of the given farm `KGB` (which had many different fields). To remedy this, new IDs were generated with the format `a_###f_#` where `a_` represents the farm, and `f_` represents the respective field of that farm. The farm names needed to be shortened because the SWAT+ model often cannot handle long ID names (longer than 16 characters)

Note, the potential measures polygons were not counted as individual fields, which is why `SP_ID` does not match up with `field_ID` -- This is by design.

```{r paged.print=TRUE}
readr::read_csv("model_data/farm_id/a_f_id.csv", show_col_types = F) %>% head()
```

This was done in a simple QGIS workflow of dissolving by farm, splitting from single part to multipart, and then adding an iterating ID per farm field. This workflow could be replicated in R, and then shown here. It is under consideration...

BuildR will now run some checks on our land layer.

```{r, check_layer_attributes1, eval=run_code}
land <- read_sf(land_path) %>% 
  check_layer_attributes(., type_to_lower = FALSE) %>%
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'land', type = 'vector')

check_polygon_topology(layer = land, data_path =  data_path, label = 'land', 
                       area_fct =  0.00, cvrg_frc = 99.9,
                       checks = c(T,F,T,T,T,T,T,T))
```

BuildR splits the land layer into HRU (land) and reservoir (water) objects

```{r, split_land_layer, eval=run_code}
split_land_layer(data_path)
```

### Processing the Channels

No documentation exists on the creation of the channels layer, all we know is that it is located here:

```{r channel_plot_x, fig.align='center', fig.cap="CS10 Channels including surface and subsurface channels"}
channel_path <- 'model_data/input/line/cs10_channels.shp'
channels <- read_sf(channel_path) %>% dplyr::select("type")

channel_map <- ggplot2::ggplot() + ggplot2::geom_sf(data = bound_sf) + 
  ggplot2::geom_sf(data = channels, mapping = ggplot2::aes(color = type)) + sf_theme

channel_map
```

BuildR runs some checks:

```{r, channelcheck, eval=run_code}
 channel <- read_sf(channel_path) %>% 
    check_layer_attributes(., type_to_lower = TRUE) %>% 
    check_project_crs(layer = ., data_path =  data_path,
                      proj_layer = project_layer, 
                      label = 'channel', type = 'vector')

check_line_topology(layer = channel, data_path = data_path,
                    label = 'channel', length_fct = 0, can_cross = FALSE)
```

BuildR then checks the connectivity between the channels and reservoirs. For this we need to define our `id_cha_out` and `id_res_out`.

"Variable `id_cha_out` sets the outlet point of the catchment. Either define a channel OR a reservoir as the final outlet. If channel then assign `id_cha_out` with the respective id from the channel layer. If reservoir then assign the respective id from the land layer to id_res_out, otherwise leave as `NULL`"

```{r, chaidout}
id_cha_out <- 37
id_res_out <- NULL
```

Running connectivity checks between channels and reservoirs:

```{r, check_cha_res_connectivity, eval=run_code}
check_cha_res_connectivity(data_path, id_cha_out, id_res_out)
```

Checking if any defined channel ids for drainage from land objects do not exist

```{r, check_land_drain_ids, eval=run_code}
check_land_drain_ids(data_path)
```

### Processing the DEM

BuildR loads and checks the DEM, and saves it.

```{r, procDEM, message=TRUE, eval=run_code}
dem <- rast(dem_path) %>% 
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'dem', type = 'raster')

check_raster_coverage(rst = dem, vct_layer = 'land', data_path = data_path, 
                      label = 'dem', cov_frc = 0.95)
save_dem_slope_raster(dem, data_path)
```

Here is the result:

```{r demcropplot, fig.cap="CS10 DEM cropped to basin", message=FALSE, warning=FALSE,  fig.align='center'}

map <- raster::raster("model_data/cs10_setup/optain-cs10/data/raster/dem.tif")
plot(map)

```

### Processing soil data

Our soil map is located here:

```{r, soil_layer_path}
soil_layer_path  <- 'model_data/input/soil/soil_layer.tif'
```

No documentation exists on its creation.

```{r soilrastermapplot, fig.align='center', fig.cap="CS10 Soil map", message=FALSE, warning=FALSE, echo=T}
plot(raster::raster(soil_layer_path))
```

The soil data and look-up path are located here:

```{r, soil_lookup_path}
soil_lookup_path <- 'model_data/input/soil/soil_lookup.csv'
soil_data_path   <- 'model_data/input/soil/UserSoil_Krakstad.csv'
```

Not much documentation exists here either. Some can be found in the excel sheet:

`~/model_data/input/soil/swatsoil2.xlsx`

BuildR reads in the soil data, performs checks, processes, and saves.

```{r message=FALSE, warning=FALSE, checksoil1, eval=run_code}
soil <- rast(soil_layer_path) %>% 
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'soil', type = 'raster')
check_raster_coverage(rst = soil, vct_layer = 'hru', data_path = data_path, 
                      label = 'soil', cov_frc = 0.75)

save_soil_raster(soil, data_path)
```

BuildR then generates a table with aggregated elevation, slope, soil for HRU units.

```{r message=FALSE, warning=FALSE, aggregate_hru_dem_soil, eval=run_code}
aggregate_hru_dem_soil(data_path)
```

Read and prepare the soil input tables and a soil/hru id table and write them into `data_path/tables.sqlite`

```{r, build_soil_data, eval=run_code}
build_soil_data(soil_lookup_path, soil_data_path, data_path)
```

## Calculating Contiguous Object Connectivity

SWATBuildR follows COCOA. This section contains the calculations. You can read more about it in the protocol.

### Calculating land unit connectivity

Preparing raster layers based on the DEM and the surface channel objects that will be used in the calculation of the land object connectivity.

```{r, prepare_terrain_land, eval=run_code}
prepare_terrain_land(data_path)
```

The connection of each land object to neighboring land and water objects is calculated based on the flow accumulation and the D8 flow pointer along the object edge

```{r message=FALSE, warning=FALSE, calculate_land_connectivity, eval=FALSE, results='hide'}
calculate_land_connectivity(data_path)
```

#### Eliminate land object connections with small flow fractions:

For each land object the flow fractions are compared to connection with the largest flow fraction of that land object. Connections are removed if their fraction is smaller than `frc_thres` relative to the largest one.

This is necessary to:

1.  Simplify the connectivity network

2.  To reduce the risk of circuit routing between land objects. Circuit routing will be checked.

If an error due to circuit routing is triggered, then 'frc_thres' must be increased to remove connectivities that may cause this issue.

```{r, frc_thres}
frc_thres <- 0.3
```

The remaining land object connections are analyzed for infinite loop routing. For each land unit the connections are propagated and checked if the end up again in the same unit.

```{r, reduce_land_connections, eval=run_code}
# reduce_land_connections(data_path, frc_thres) %>% 
#  check_infinite_loops(., data_path, 'Land')
```

```{r}
# Analyzing land objects for infinite loop routing: Completed 6185 Land objects
# in 10M 44S
#
# ✘  150 Land objects identified where water is routed in loops.
#
# You can resolve this issue in the following ways:
#
#  - Use the layer 'land_infinite_loops.gpkg' that was written to
# model_data/cs10_setup/optain-cs10/data/vector to identify land polygons that
# cause the issue and split them to break the loops This would require to
# restart the entire model setup procedure!
#
#   - Increase the value of 'frc_thres'.
# This reduces the number of connections of each land unit (maybe undesired!)
# and can remove the connections that route the water in loops.
#
#   - Continue with the model setup (only recommended for small number of identified units!).
# The function 'resolve_loop_issues()' will then eliminate a certain number of
# connections.
```

What do we do here ? -- I think in the past Alex just removed all the loops, but it says here it is not recommended when there are a lot of them. Should we increase the threshold? Should we try to break up the loops? You can see the problem polygons on the map below:

```{r}
land_inifnite_loops_shp <- sf::read_sf("model_data/cs10_setup/optain-cs10/data/vector/land_infinite_loops.gpkg")

mapview::mapview(land_inifnite_loops_shp)
```

To me it seems to complicated to try to break up the loops, maybe increase the threshold a bit and see what happens? and delete the rest?

Increasing threshold and re-running leads to this:

```{r, frc_thres2}
frc_thres <- 0.1 # xxx loops (   mins)
frc_thres <- 0.2 # 238 loops (30 mins)
frc_thres <- 0.3 # 150 loops (12 mins)
frc_thres <- 0.4 # 115 loops (   mins)
frc_thres <- 0.5 # 94  loops (   mins)
frc_thres <- 0.6 # 57  loops (   mins)
```

We have decided that at a threshold of 0.3 and 150, we are within the "not that many" loops territory, considering out of 6000+ HRUs, it is only around 2%. Therefore we will let BuildR continue and remove them.

```{r}
frc_thres <- 0.3 # 150 loops

reduce_land_connections(data_path, frc_thres) %>% 
  check_infinite_loops(., data_path, 'Land')
```

#### Resolve infinite loops

If infinite loops were identified this routine tries to resolve the issues by selectively removing connections between land units in order to get rid of all infinite loops.

```{r, resolve_loop_issues, eval=run_code}
 resolve_loop_issues(data_path)
```

### Calculating channel/reservoir connectivity

#### Calculating the water object connectivity

the function returns the `cha` and `res` `con_out` tables in SWAT+ database format and writes them into `data_path/tables.sqlite`

```{r, build_water_object_connectivity, eval=run_code}
build_water_object_connectivity(data_path)
```

### Checking the water objects for infinite loops

From the `cha_res_con_out` tables `id_from`/`id_to` links are generated and checked for infinite loop routing.

```{r, prepare_water_links, eval=run_code}
prepare_water_links(data_path) %>% 
  check_infinite_loops(., data_path, 'Water', Inf)
```

### Terrain properties

Calculate terrain properties such as elevation, slope, catchment area, channel width/depth for channel and reservoir objects and write them into `data_path/tables.sqlite`

```{r, prepare_terrain_water, eval=run_code}
prepare_terrain_water(data_path)
```

## Generate SWAT+ input

### Generate land object SWAT+ input tables

Build the `landuse.lum` and a landuse/hru id table and write them into `data_path/tables.sqlite`

```{r, build_landuse, eval=run_code}
build_landuse(data_path)
```

Build the HRU SWAT+ input files and write them into `data_path/tables.sqlite`

```{r, build_hru_input, eval=run_code}
build_hru_input(data_path)
```

Add wetlands to the HRUs and build the wetland input files and write them into `data_path/tables.sqlite`

We only use the `wetf` land use .

```{r, wetland_landuse}
wetland_landuse <- c('wehb', 'wetf', 'wetl', 'wetn')
```

```{r, add_wetlands, eval=run_code}
add_wetlands(data_path, wetland_landuse)
```

### Generate water object SWAT+ input tables

Build the SWAT+ `cha` input files and write them into `data_path/tables.sqlite`

```{r, build_cha_input, eval=run_code}
build_cha_input(data_path)
```

Build the SWAT+ res input files and write them into `data_path/tables.sqlite`

```{r, build_res_input, eval=run_code}
build_res_input(data_path)
```

Build SWAT+ routing unit con_out based on 'land_connect_fraction'.

```{r, build_rout_con_out, eval=run_code}
build_rout_con_out(data_path)
```

Build the SWAT+ rout_unit input files and write them into `data_path/tables.sqlite`

```{r, build_rout_input, eval=run_code}
build_rout_input(data_path)
```

Build the SWAT+ LSU input files and write them into `data_path/tables.sqlite`

```{r, build_ls_unit_input, eval=run_code}
build_ls_unit_input(data_path)
```

### Build aquifer input

Build the SWAT+ aquifer input files for a single aquifer for the entire catchment. The connectivity to the channels with geomorphic flow must be added after writing the `txt` input files. **This is not implemented in the script yet.**

```{r, build_single_aquifer_files, eval=run_code}
build_single_aquifer_files(data_path)
```

### Add point source inputs

The point source locations are provided with a point vector layer in the path 'point_path'.

We have yet to complete this step. It is being tracked in Issue [\# 21](https://gitlab.nibio.no/moritzshore/swat-cs10/-/issues/21)

```{r, point_path}
point_path <- 'model_data/input/point/cs10_pointsource.shp'
```

```{r, pointsoucemap, fig.align='center', fig.cap="CS10 Point Sources, colored by Phosphorous emission and sized by Nitrogen emission"}
point_sf <- sf::read_sf(point_path)
point_map <- mapview::mapview(point_sf, zcol = "GRAD_P", cex = "GRAD_N")

mapview::mapview(bound_sf, alpha.regions = 0.2)+point_map
```

Map of point sources, colored by (assumed) phosphorous and size by (assumed) Nitrogen

Maximum distance of a point source to a channel or a reservoir to be included as a point source object (recall) in the model setup:

```{r, max_point_dist}
max_point_dist <- 500 # meters
```

Point source records can automatically be added from files in the same folder as the point source location layer. To be identified as point source data the files must be named as `<name>_<interval>.csv`, where `<name>` must be the name of a point `int` the vector layer and `<interval>` must be one of `const`, `yr`, `mon`, or `day` depending on the time intervals in the input data.

```{r, add_point_sources, eval=run_code}
add_point_sources(point_path, data_path, max_point_dist)
```

### Create SWAT+ sqlite database

#### Write the SWAT+Editor project database

The database will be located the 'project_path'.

```{r, create_swatplus_database, eval=run_code}
create_swatplus_database(project_path, project_name)
```
