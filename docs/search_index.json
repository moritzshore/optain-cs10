[["scheduling-managment-with-swatfarmr.html", "Chapter 5 Scheduling Managment with SWATFarmR 5.1 Introduction 5.2 Pre-processing crop rotation 5.3 Initializing FarmR 5.4 Calculating Antecedent Precipitation Index 5.5 Scheduling Operations 5.6 Write Operations", " Chapter 5 Scheduling Managment with SWATFarmR 5.1 Introduction WIP: Every field in the OPTAIN SWAT setup needs its own management. We will use the SWATFarmR package to define it. 5.1.1 Pre-requirements The creation of management schedules with SWATfarmR requires a SWAT+ model setup created by the SWATbuildR package. We also require the following packages: require(DT) require(gifski) require(ggplot2) require(readr) require(stringr) require(magrittr) #remotes::install_github(&quot;chrisschuerz/SWATfarmR&quot;) require(SWATfarmR) 5.2 Pre-processing crop rotation This OPTAIN-provided workflow pre-processes our crop rotation data into a SWATfarmR compatible format. Authored by Michael Strauch, modified by Moritz Shore It requires the following packages require(sf) require(tidyverse) require(lubridate) require(reshape2) require(remotes) require(dplyr) require(data.table) And the following functions: source(&#39;model_data/swat_farmR/functions_write_SWATfarmR_input.R&#39;) 5.2.1 Input files 5.2.1.1 Land use map with crop information This map has the following requirements: The map must contain the land use of each hru. In case of cropland, the names must be unique for each field (e.g., ‘field_1’, ‘field_2’, etc.) The map must also contain crop infos for the period 1988 to 2020 (or 2021 if crop info available). This requires an extrapolation of the available crop sequences (the sequences derived from remote-sensing based crop classification or local data). The extrapolated crop sequence for 33 years will be also used for running climate scenarios and must not contain any gaps. That means, gaps have to be closed manually! The year columns must be named y_1988, y_1989, etc. The crop infos for each year must match the crop_mgt names in the management operation schedules (provided in a .csv file, see below) see also section 4.1 of the modelling protocol (ref) lu_shp &lt;- &#39;model_data/input/crop/land_with_cr.shp&#39; lu &lt;- st_drop_geometry(read_sf(lu_shp)) datatable( lu %&gt;% head(50), extensions = &quot;Scroller&quot;, options = list(scrollY = 200, scroller = TRUE) ) The crop rotation looks like this: (#fig:cro_gif)Generated crop rotation for CS10. 5.2.1.2 Management operation schedules for each crop ..or, if available, crop-management type. All schedules must be compiled in one csv file (see example in demo data and study also section 4.2 of the modelling protocol) ‘crop_mgt’ must start with the 4-character SWAT crop names (any further management specification is optional). Each schedule must contain a ‘skip’ line to indicate the change of years. The ‘skip’ line should never be the last line of a schedule. mgt_csv &lt;- &#39;model_data/input/management/mgt_crops_CS10.csv&#39; mgt_crop &lt;- read.csv(mgt_csv) datatable(mgt_crop, extensions = &quot;Scroller&quot;, options = list(scrollY = 200, scroller = TRUE)) 5.2.1.3 Management operation schedules for generic land-use classes Usually all non-cropland classes with vegetation cover here, all schedules must be provided already in the SWATfarmR input format. lu_generic_csv &lt;- &#39;model_data/input/management/farmR_generic_CS10.csv&#39; # generic land use management .csv table mgt_generic &lt;- read.csv(lu_generic_csv) datatable(mgt_generic) 5.2.2 Settings 5.2.2.1 Simulation Period start_y &lt;- 1988 # starting year (consider at least 3 years for warm-up!) end_y &lt;- 2020 # ending year 5.2.2.2 Prefix of cropland hrus all names of hrus with a crop rotation must begin with this prefix in column ‘lu’ of your land use hru_crops &lt;- &#39;a_&#39; 5.2.2.3 Multi-year farmland grass Did you define any multi-year farmland grass schedules? ‘y’ (yes), ‘n’ (no) m_yr_sch_existing &lt;- &#39;n&#39; If yes, define also the following variables. If not, skip next four lines crop_myr &lt;- &#39;past&#39; # name of your farmland grass Maximum number of years farmland grass can grow before it is killed (should be &lt;8) max_yr &lt;- 5 Do your multi-year farmland grass schedules consider the type of the following crop (summer or winter crop)? (e.g., a ’_1.5yr’ schedule with a kill op in spring allows for planting a summer crop immediately afterwards) If yes, you must define your summer crops crop_s &lt;- c(&#39;sgbt&#39;,&#39;csil&#39;,&#39;barl&#39;) Do your summer crop schedules usually start with an operation in autumn (e.g. tillage)? To combine them with farmland grass, it is necessary that you provide ‘half-year-schedules’ (‘half-year-schedules’ are additional summer crop schedules without operations in autumn) The adapted schedules should be added to the crop management table with suffix ’_0.5yr’ (e.g. ‘csil_0.5yr’) If additional ‘half-year-schedules’ are not needed, because your normal summer crop schedules do not start in autumn, type ‘n’ additional_h_yr_sch_existing &lt;- &#39;n&#39; # &#39;y&#39; (yes), &#39;n&#39; (no) 5.2.3 Checks Check for correct positioning of ‘skip’ line check_skip &lt;- check_skip_position() ## [1] &quot;Check successfull&quot; Check for date conflicts in single crop schedules check_date_conflicts1() ## [1] &quot;check single schedule for crop 1&quot; ## [1] &quot;check single schedule for crop 2&quot; ## [1] &quot;check single schedule for crop 3&quot; ## [1] &quot;check single schedule for crop 4&quot; ## [1] &quot;check single schedule for crop 5&quot; ## [1] &quot;check single schedule for crop 6&quot; ## [1] &quot;No conflicts detected :)&quot; Build schedules for crop sequences (Messages disabled) rota_schedules &lt;- build_rotation_schedules() Check for date conflicts in the full rotation schedule. (Messages disabled) check_date_conflicts2() Solve minor date conflicts (where only a few days/weeks are overlapping) (Messages disabled) rota_schedules &lt;- solve_date_conflicts() Check again for date conflicts (Messages disabled) check_date_conflicts2() 5.2.4 Writing input data Write the SWAT farmR input table write_farmR_input() ## [[1]] ## [1] &quot;The SWATfarmR input is written to &#39;model_data/input/management/farmR_input.csv&#39;.&quot; ## ## [[2]] ## [1] &quot;If appropriate, add management schedules for generic land covers, such as orchards, pastures and meadows.&quot; ## ## [[3]] ## [1] &quot;(example schedules for generic land covers in SWATfarmR format are provided in farmR_lulc_generic.csv)&quot; ## ## [[4]] ## [1] &quot;Use this file as input for the SWATfarmR package.&quot; The output of this pre-processing stage is loaded in from this file: farmR_input &lt;- readr::read_csv(&quot;model_data/input/management/farmR_input.csv&quot;, show_col_types = F) datatable( head(farmR_input, 50), extensions = &quot;Scroller&quot;, options = list(scrollY = 200, scroller = TRUE) ) TODO: Figure out why this is an issue. Are you using the wrong buildR output as source material for the crop generation? We need to fix the land use name, which entails replacing the _drn_lum with just _lum for all the agricultural fields. This is because land.shp from buildR does not include the _drn for some reason # TODO: Figure out why this is an issue. Are you using the wrong buildR output # as source material for the crop generation? farmR_input2 &lt;- farmR_input %&gt;% filter(grepl(x = land_use, &quot;a_&quot;)) %&gt;% mutate(land_use = str_replace(.$land_use, &quot;_lum&quot;, &quot;_drn_lum&quot;)) farmR_input3 &lt;- farmR_input %&gt;% filter(!grepl(x = land_use, &quot;a_&quot;)) farmR_input4 &lt;- rbind(farmR_input2, farmR_input3) write_csv(farmR_input4, file =&quot;model_data/input/management/farmR_input2.csv&quot;) rm(farmR_input, farmR_input2, farmR_input3, farmR_input4) # Yes I am aware that code is bad and ugly. 5.3 Initializing FarmR If the FarmR has never been initialized, then use new_farmr() and read_management(), otherwise load_farmr(). EVAL FALSE as BuildR script is still broken project_path &lt;- &quot;model_data/cs10_setup&quot; SWATfarmR::new_farmr(project_name = &quot;cs10&quot;, project_path = project_path ) #load_farmr(...) cs10$read_management(file = &quot;farmR_input/farmR_input2.csv&quot;) 5.4 Calculating Antecedent Precipitation Index USING TEMPORARY API: This needs to be replaced with a proper model. See issue #17 EVAL FALSE as BuildR script is still broken # Load dplyr. We will use functions such as &#39;mutate&#39; and &#39;select&#39;. library(dplyr) # Extract the precipitation from the farmr project pcp &lt;- cs10$.data$variables$pcp # Extract the hydrologic soil group values for all HRUs hsg &lt;- select(cs10$.data$meta$hru_attributes, hru, hyd_grp) # Calculate api values for the hsg classes A to D api_A &lt;- variable_decay(variable = pcp, n_steps = -5, decay_rate = 1) api_B &lt;- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.8) api_C &lt;- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.7) api_D &lt;- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.5) # Bind the data together into one api table and name them with the hsgs api &lt;- bind_cols(api_A, api_B, api_C, api_D) names(api) &lt;- c(&#39;api_A&#39;, &#39;api_B&#39;, &#39;api_C&#39;, &#39;api_D&#39;) # To add the variable to the farmR you have to tell it which variables are # assigned to which HRUs hru_asgn &lt;- mutate(hsg, api = paste0(&#39;api_&#39;, hyd_grp)) %&gt;% select(hru, api) # Add the variable api to the farmR project cs10$add_variable(data = api, name = &#39;api&#39;, assign_unit = hru_asgn, overwrite = T) From (patrignani2020?): The API is a well-known, parsimonious, recursive model for predicting soil moisture solely based on precipitation records. The API is commonly implemented using daily precipitation records, but it is possible to work at finer temporal scales (e.g. hourly) if both precipitation (model input) and soil moisture (for validation purposes) are available. The equation describing the simples version of the model is: \\[API_{t} = \\alpha API_{t-1} + P_t\\] \\(API_t\\): Soil water content at time \\(t\\) (today) \\(API_{t-1}\\): Soil water content at time \\(t-1\\) (yesterday) \\(\\alpha\\): Loss coefficient. Range between 0 and 1 \\(P_t\\): Precipitation at time \\(t\\) (today) Following Python code modified from (patrignani2020?) (read more) Just do it in R… bokeh wont place nice and we need to do some annoying time date stuff …. 5.5 Scheduling Operations EVAL FALSE as BuildR script is still broken cs10$schedule_operations(start_year = 2010, end_year = 2020, n_schedule = 2) 5.6 Write Operations EVAL FALSE as BuildR script is still broken We cannot write from 1988 as it is limited to our climate data, which currently only spans back to 2010 cs10$write_operations(start_year = 2010, end_year = 2020) "]]
