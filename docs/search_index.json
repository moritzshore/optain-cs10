[["index.html", "OPTAIN CS-10 Chapter 1 Introduction", " OPTAIN CS-10 Moritz Shore, Csilla Farkas 2023-05-19 Chapter 1 Introduction This is the documentation for the OPTAIN-CS10 Project. It is currently incomplete. Click the Arrow on the right to continue! "],["model-setup-with-swatbuildr.html", "Chapter 2 Model setup with SWATBuildR 2.1 High-Resolution Digital Elevation Model (DEM) 2.2 Processing the Basin Boundary 2.3 Processing the Land layer 2.4 Processing the Channels 2.5 Processing the DEM 2.6 Processing soil data 2.7 Calculating land unit connectivity 2.8 Calculating channel/reservoir connectivity 2.9 Terrain properties 2.10 Generate land object SWAT+ input tables 2.11 Generate water object SWAT+ input tables 2.12 Build aquifer input 2.13 Add point source inputs 2.14 Create SWAT+ sqlite database 2.15 TODO 2.16 Link aquifers and channels with geomorphic flow", " Chapter 2 Model setup with SWATBuildR The OPTAIN project is using the COCOA approach Schürz et al. (2022) and as such, needs to use the SWATBuildR package to calculate the connectivity between HRUs in the catchment. This chapter covers this process. We will define the location of our project here: project_path &lt;- &#39;model_data/cs10_setup&#39; And give it the name: project_name &lt;- &#39;optain-cs10&#39; Much of this documentation has been lost to time. We will need the following packages for this chapter: require(mapview) require(sf) require(raster) 2.1 High-Resolution Digital Elevation Model (DEM) The high-resolution DEM is the basis for calculation of water connectivity, among other things. Most of the documentation of the creation of the DEM for CS10 has been lost to the sands of time. All we know is that it is located here: dem_path &lt;- &quot;model_data/input/elevation/dtm3_ns_v5.tif&quot; plot(raster(dem_path), main = &quot;CS10 DEM, UTM32N&quot;) To our knowledge, it has a 10 meter resolution. 1 meter resolution was available but there seems to have been issues with using it. It is definitely preferable to use the 1m DEM as certain important information can be lost with (max allowed resolution) of 10m. An example of a hydrologically effective landscape features being lost due to coarse DEM resolution. From(Schürz et al. 2022) 2.2 Processing the Basin Boundary The basin boundary has presumably been created using the defined outlet point of the catchment and the DEM. No more is currently known about this file other than that it is located here: bound_path &lt;- &quot;model_data/input/shape/cs10_basin.shp&quot; We will begin using the SWATBuildR Package by initializing its functions. (Note: this package is currently unfinished, which is why this step is necessary). The following code and commentary is from version 1.5.12, written by Christoph Schuerz. Another note: there are currently issues with White box which are being resolved. source(&#39;model_data/swat_buildR/init.R&#39;) ## Warning in fun(libname, pkgname): GEOS versions differ: lwgeom has 3.9.1 sf has ## 3.9.3 ## Warning in fun(libname, pkgname): PROJ versions differ: lwgeom has 7.2.1 sf has ## 8.2.1 BuildR recommends all layers to be in the same CRS, if we set project_layer to FALSE, it will throw an error when this is not the case: The input layers might be in different coordinate reference systems (CRS). It is recommended to project all layers to the same CRS and check them before using them as model inputs. The model setup process checks if the layer CRSs differ from the one of the basin boundary. By setting ‘proj_layer &lt;- TRUE’ the layer is projected if the CRS is different. If FALSE different CRS trigger an error. project_layer &lt;- TRUE We read in and check the basin boundary and run some checks bound &lt;- read_sf(bound_path) %&gt;% select() set_proj_crs(bound, data_path) check_polygon_topology(layer = bound, data_path = data_path, label = &#39;basin&#39;, n_feat = 1, checks = c(F,T,T,T,F,F,F,F)) ## Running topological checks and modifications for the basin layer: ## ## Analyzing basin layer for specific number of features... ## ✔ Number of features correct. ## Analyzing basin layer for MULTIPOLYGON features... ## ✔ No MULTIPOLYGON features identified. ## Analyzing basin layer for invalid features... ## ✔ No invalid features identified. ## ## ## ✔ All checks successful! Saving checked basin layer. 2.3 Processing the Land layer Our land layer is located here: land_path &lt;- &quot;model_data/input/land/CS10_LU.shp&quot; Documentation on its creation does not exist. Interactive land use map of CS10 by Farm ID We had an issue with the classification of the land uses. For the OPTAIN project, all agricultural fields must have a unique ID, and our land uses only had the ID of the given farm KGB (which had many different fields). To remedy this, new IDs were generated with the format a_###f_# where a_ represents the farm, and f_ represents the respective field of that farm. The farm names needed to be shortened because the SWAT+ model often cannot handle long ID names (longer than 16 characters) readr::read_csv(&quot;model_data/farm_id/a_f_id.csv&quot;, show_col_types = F) %&gt;% head() ## # A tibble: 6 × 4 ## KGB type_fr sp_id field_ID ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 213/8/1 a_084 1 a_084f_1 ## 2 213/7/6 a_083 2 a_083f_1 ## 3 213/7/6 a_083 3 a_083f_2 ## 4 213/7/4 a_082 4 a_082f_1 ## 5 213/65/1 a_081 5 a_081f_1 ## 6 213/65/1 a_081 6 a_081f_2 This was done in a simple QGIS workflow of dissolving by farm, splitting from single part to multipart, and then adding an iterating ID per farm field. This workflow could be replicated in R, and then shown here. It is under consideration… This is our map with the new type IDs: lu_map &lt;- mapview(read_sf(land_path), zcol = &quot;type&quot;, legend = FALSE) lu_map interactive land use map of CS10 by Field ID BuildR will now run some checks on our land layer. land &lt;- read_sf(land_path) %&gt;% check_layer_attributes(., type_to_lower = FALSE) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;land&#39;, type = &#39;vector&#39;) check_polygon_topology(layer = land, data_path = data_path, label = &#39;land&#39;, area_fct = 0.00, cvrg_frc = 99.9, checks = c(T,F,T,T,T,T,T,T)) ## Running topological checks and modifications for the land layer: ## ## Intersection of land layer with basin boundary layer... ## ✔ Intersection completed. ## Analyzing land layer for MULTIPOLYGON features... ## ✔ No MULTIPOLYGON features identified. ## Analyzing land layer for invalid features... ## ✔ No invalid features identified. ## Analyzing land layer for very small feature areas... ## ✔ No small features identified. ## Analyzing land layer for features covered by other features... ## ✔ No covered features identified. ## Analyzing land layer for overlapping features... ## ✔ No overlapping features identified. ## Analyzing land layer coverage with basin boundary... ## ✔ Layer coverage OK. ## ## ## ✔ All checks successful! Saving intersected land layer. BuildR splits the land layer into HRU (land) and reservoir (water) objects split_land_layer(data_path) 2.4 Processing the Channels No documentation exists on the source of the channels layer, all we know is that it is located here: channel_path &lt;- &#39;model_data/input/line/cs10_channels.shp&#39; channels &lt;- read_sf(channel_path) %&gt;% select(&quot;type&quot;) plot(channels) BuildR runs some checks: channel &lt;- read_sf(channel_path) %&gt;% check_layer_attributes(., type_to_lower = TRUE) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;channel&#39;, type = &#39;vector&#39;) check_line_topology(layer = channel, data_path = data_path, label = &#39;channel&#39;, length_fct = 0, can_cross = FALSE) ## Running topological checks and modifications for the channel layer: ## ## Intersection of channel layer with basin boundary layer... ## ✔ Intersection completed. ## Analyzing channel layer for MULTILINE features... ## ✔ No MULTILINE features identified. ## Analyzing channel layer for invalid features... ## ✔ No invalid features identified. ## Analyzing channel layer for very short feature lengths... ## ✔ No small features identified. ## Analyzing channel layer for crossing features... ## ✔ No crossing features identified. ## ## ✔ All checks successful! Saving intersected channel layer. And gives this output: channels &lt;- read_sf(&quot;model_data/cs10_setup/optain-cs10/data/vector/channel.shp&quot;) channel_map &lt;- mapview(channels, zcol = &quot;type&quot;) bound_map+channel_map BuildR then checks the connectivity between the channels and reservoirs. For this we need to define our id_cha_out and id_res_out. Variable id_cha_out sets the outlet point of the catchment. Either define a channel OR a reservoir as the final outlet. If channel then assign id_cha_out with the respective id from the channel layer. If reservoir then assign the respective id from the land layer to id_res_out, otherwise leave as NULL id_cha_out &lt;- 37 id_res_out &lt;- NULL Running connectivity checks between channels and reservoirs: check_cha_res_connectivity(data_path, id_cha_out, id_res_out) ## Preparing channel and reservoir features... ## ✔ OK! ## Analyzing connectivity of water object network... ## ✔ No disconnected channels identified. ## ✔ No disconnected reservoirs identified. ## ## ## ✔ Water object connectivity check successful! Checking if any defined channel ids for drainage from land objects do not exist check_land_drain_ids(data_path) 2.5 Processing the DEM BuildR loads and checks the DEM, and saves it. dem &lt;- rast(dem_path) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;dem&#39;, type = &#39;raster&#39;) check_raster_coverage(rst = dem, vct_layer = &#39;land&#39;, data_path = data_path, label = &#39;dem&#39;, cov_frc = 0.95) save_dem_slope_raster(dem, data_path) ## [1] TRUE 2.6 Processing soil data Our soil map is located here: soil_layer_path &lt;- &#39;model_data/input/soil/soil_layer.tif&#39; No documentation exists on its creation. The soil data and lookup path are located here: soil_lookup_path &lt;- &#39;model_data/input/soil/soil_lookup.csv&#39; soil_data_path &lt;- &#39;model_data/input/soil/UserSoil_Krakstad.csv&#39; Not much documentation exists here either. Some can be found in the excel sheet: ## [1] &quot;model_data/input/soil/swatsoil2.xlsx&quot; BuildR reads in the soil data, performs checks, processes, and saves. NOTE: THIS IS CURRENTLY BROKEN, WITH ERROR MESSAGE: Warning: Cannot find coordinate operations from EPSG:2583 [“unnamed”,EDATUM[“”], CS[Cartesian,2], AXIS[“(E)”, east, ORDER[1], LENGTHUNIT[“unknown”, 1]], AXIS[“(N)”, north, ORDER[2], LENGTHUNIT[“unknown”, 1]]]’ (GDAL error 6) Error: [project] Cannot do this transformation soil &lt;- rast(soil_layer_path) %&gt;% check_project_crs(layer = ., data_path = data_path, proj_layer = project_layer, label = &#39;soil&#39;, type = &#39;raster&#39;) check_raster_coverage(rst = soil, vct_layer = &#39;hru&#39;, data_path = data_path, label = &#39;soil&#39;, cov_frc = 0.75) # BROKEN #save_soil_raster(soil, data_path) # added soil.tif from back when it used to work BuildR then generates a table with aggregated elevation, slope, soil for HRU units. # waiting on soil fix. #aggregate_hru_dem_soil(data_path) Read and prepare the soil input tables and a soil/hru id table and write them into data_path/tables.sqlite #build_soil_data(soil_lookup_path, soil_data_path, data_path) 2.7 Calculating land unit connectivity Preparing raster layers based on the DEM and the surface channel objects that will be used in the calculation of the land object connectivity. #prepare_terrain_land(data_path) The connection of each land object to neighboring land and water objects is calculated based on the flow accumulation and the D8 flow pointer along the object edge # calculate_land_connectivity(data_path) 2.7.1 Eliminate land object connections with small flow fractions: For each land object the flow fractions are compared to connection with the largest flow fraction of that land object. Connections are removed if their fraction is smaller than frc_thres relative to the largest one. This is necessary to: Simplify the connectivity network To reduce the risk of circuit routing between land objects. Circuit routing will be checked. If an error due to circuit routing is triggered, then ‘frc_thres’ must be increased to remove connectivities that may cause this issue. frc_thres &lt;- 0.3 The remaining land object connections are analyzed for infinite loop routing. For each land unit the connections are propagated and checked if the end up again in the same unit. #reduce_land_connections(data_path, frc_thres) %&gt;% # check_infinite_loops(., data_path, &#39;Land&#39;) If infinite loops were identified this routine tries to resolve the issues by selectively removing connections between land units in order to get rid of all infinite loops. # resolve_loop_issues(data_path) 2.8 Calculating channel/reservoir connectivity 2.8.1 Calculating the water object connectivity the function returns the cha and res con_out tables in SWAT+ database format and writes them into data_path/tables.sqlite #build_water_object_connectivity(data_path) 2.8.2 Checking the water objects for infinite loops From the cha_res_con_out tables id_from/id_to links are generated and checked for infinite loop routing. #prepare_water_links(data_path) %&gt;% # check_infinite_loops(., data_path, &#39;Water&#39;, Inf) 2.9 Terrain properties Calculate terrain properties such as elevation, slope, catchment area, channel width/depth for channel and reservoir objects and write them into data_path/tables.sqlite #prepare_terrain_water(data_path) 2.10 Generate land object SWAT+ input tables Build the landuse.lum and a landuse/hru id table and write them into data_path/tables.sqlite #build_landuse(data_path) Build the HRU SWAT+ input files and write them into data_path/tables.sqlite #build_hru_input(data_path) Add wetlands to the HRUs and build the wetland input files and write them into data_path/tables.sqlite (TODO fix this!) wetland_landuse &lt;- c(&#39;wehb&#39;, &#39;wetf&#39;, &#39;wetl&#39;, &#39;wetn&#39;) #add_wetlands(data_path, wetland_landuse) 2.11 Generate water object SWAT+ input tables Build the SWAT+ cha input files and write them into data_path/tables.sqlite #build_cha_input(data_path) Build the SWAT+ res input files and write them into data_path/tables.sqlite #build_res_input(data_path) Build SWAT+ routing unit con_out based on ‘land_connect_fraction’. #build_rout_con_out(data_path) Build the SWAT+ rout_unit input files and write them into data_path/tables.sqlite #build_rout_input(data_path) Build the SWAT+ LSU input files and write them into data_path/tables.sqlite #build_ls_unit_input(data_path) 2.12 Build aquifer input Build the SWAT+ aquifer input files for a single aquifer for the entire catchment. The connectivity to the channels with geomorphic flow must be added after writing the txt input files. This is not implemented in the script yet. #build_single_aquifer_files(data_path) 2.13 Add point source inputs The point source locations are provided with a point vector layer in the path ‘point_path’. point_path &lt;- &#39;model_data/input/point/cs10_pointsource.shp&#39; point_sf &lt;- read_sf(point_path) point_map &lt;- mapview(point_sf, zcol = &quot;GRAD_P&quot;, cex = &quot;GRAD_N&quot;) point_map+channel_map+bound_map Map of point sources, colored by (assumed) phosphorous and size by (assumed) Nitrogren Maximum distance of a point source to a channel or a reservoir to be included as a point source object (recall) in the model setup: max_point_dist &lt;- 500 #meters Point source records can automatically be added from files in the same folder as the point source location layer. To be identified as point source data the files must be named as &lt;name&gt;_&lt;interval&gt;.csv, where &lt;name&gt; must be the name of a point int the vector layer and &lt;interval&gt; must be one of const, yr, mon, or day depending on the time intervals in the input data. #add_point_sources(point_path, data_path, max_point_dist) 2.14 Create SWAT+ sqlite database 2.14.1 Write the SWAT+Editor project database The database will be located the ‘project_path’. After writing the database it can be opened and edited with the SWAT+Editor. #create_swatplus_database(project_path, project_name) The next step involves you entering the SWAT+ Editor and parameterizing the model from there. These are the steps we have taken, with screenshots since it is currently not possible to replicate this process in R. 2.15 TODO Switch to SWAT+Editor for further model parametrization and continue with the step below after writing the SWAT+ projects’ text input files 2.16 Link aquifers and channels with geomorphic flow A SWATbuildR model setup only has one single aquifer (in its current version). This aquifer is linked with all channels through a channel- aquifer-link file (aqu_cha.lin) in order to maintain recharge from the aquifer into the channels using the geomorphic flow option of SWAT+ The required input file cannot be written with the SWAT+Editor. Therefore it has to be generated in a step after writing the model text input files with the SWAT+Editor. Path of the TxtInOut folder (project folder where the SWAT+ text files are written with the SWAT+Editor) txt_path &lt;- &#39;../swat_runs/txtinouit/&#39; #link_aquifer_channels(txt_path) References "],["climate-inputs-and-weather-generator.html", "Chapter 3 Climate inputs and weather generator 3.1 Channel parameters revised 3.2 Crop parameters verified 3.3 Soil physical parameters in final form 3.4 Soil chemical parameters in final form 3.5 Impoundment parameters defined 3.6 Water diversions defined 3.7 Point sources parameters added 3.8 Tile drainage parameters defined 3.9 Atmospheric deposition defined 3.10 Additional settings verified", " Chapter 3 Climate inputs and weather generator Hello world 3.1 Channel parameters revised 3.2 Crop parameters verified 3.3 Soil physical parameters in final form 3.4 Soil chemical parameters in final form 3.5 Impoundment parameters defined 3.6 Water diversions defined 3.7 Point sources parameters added 3.8 Tile drainage parameters defined 3.9 Atmospheric deposition defined 3.10 Additional settings verified Refers to chapter 3.11 in The Protocol dontt miss Table 3.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 3.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["landuse.lum-update.html", "Chapter 4 Landuse.lum update", " Chapter 4 Landuse.lum update "],["footnotes-and-citations.html", "Chapter 5 Footnotes and citations 5.1 Footnotes 5.2 Citations", " Chapter 5 Footnotes and citations 5.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 5.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2023) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations References "],["blocks.html", "Chapter 6 Blocks 6.1 Equations 6.2 Theorems and proofs 6.3 Callout blocks", " Chapter 6 Blocks 6.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 6.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 6.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 7 Sharing your book 7.1 Publishing 7.2 404 pages 7.3 Metadata for sharing", " Chapter 7 Sharing your book 7.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 7.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 7.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["references.html", "References", " References "]]
