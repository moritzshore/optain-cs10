[["input-data-preparation.html", "Section 1 Input Data Preparation 1.1 Digital Elevation Model 1.2 Soil Data 1.3 Watershed Boundary 1.4 Land object input 1.5 Channel object input 1.6 Point sources locations 1.7 Aquifer Objects", " Section 1 Input Data Preparation The actual creation of the input files will not be covered, since these steps were performed before the documentation project, by a different team member who is no longer active in the project. We will need the following libraries. require(raster) require(sf) require(ggplot2) require(mapview) require(dplyr) require(sp) require(terra) require(gifski) # Common ggplot theme for simple features sf_theme &lt;- theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ) Required vector and raster inputs for a SWAT+ model setup with SWATbuildR. (From Schürz et al. (2022)) 1.1 Digital Elevation Model The file is located here. No documentation exists. dem_path &lt;- &quot;model_data/input/elevation/dtm3_ns_v5.tif&quot; dem_rast &lt;- raster(dem_path) plot(dem_rast) Figure 1.1: CS10 Digital elevation model (DEM). To our knowledge, it has a 10 meter resolution. 1 meter resolution was available but there seems to have been issues with using it. It is definitely preferable to use the 1m DEM as certain important information can be lost with (max allowed resolution) of 10m. An example of a hydrologically effective landscape features being lost due to coarse DEM resolution. From (Schürz et al. 2022) 1.2 Soil Data Required are: a GeoTiff raster layer that defines the spatial locations of the soil classes (with integer ID values). &quot;model_data/input/soil/soil_layer.tif&quot; a lookup table in .csv format, which links the IDs of the soil classes with their names &quot;model_data/input/soil/soil_lookup.csv&quot; a usersoil table in .csv format, which provides physical and chemical parameters of all soil layers for each soil class that is defined in the raster layer and the lookup table. An example soil dataset can be acquired e.g. from the ExampleDatasets folder which comes with an installation of SWAT+. &quot;model_data/input/soil/UserSoil_Krakstad.csv&quot; A high resolution soil map is required to accurately represent the Hydrologic Response Units (HRUs) used in the OPTAIN project: Spatially adequate representation of soil heterogeneity on field plot scale. The different colours represent different soil classes. The black border lines represent the boundaries of spatial objects (e.g. agricultural fields). a) the original soil input layer. b) the dominant soil aggregation as performed by SWATbuildR. Schürz et al. (2022) The use of soil information on a scale which is much more detailed than the scale of the spatial objects in a model setup is however not recommended. It might be difficult to provide parameters to the usersoil table for less common soil types. Moreover, by default SWATbuildR uses the dominant soil class for each spatial object in the model setup process (see Figure 2.3b). Thus, a great share of the detailed information would get lost during the model setup process. One exception from that rule may be soil physical data which are available in a raster format Our soil map is created from merging two separate datasets, the first being Jordsmonn (Viken) from NIBIO and Loesmasser from NGU. We don’t currently know how they were combined to create the final soil map. It is located here soil_path &lt;- &quot;model_data/input/soil/soil_map_UTM32N.shp&quot; Lets have a look: soil_shp &lt;- read_sf(soil_path) soil_plot &lt;- ggplot(soil_shp) + geom_sf() + sf_theme print(soil_plot) 1.3 Watershed Boundary The watershed boundary must be a single polygon GIS vector layer. No documentation for our polygon exists. It is located here: basin_path &lt;- &quot;model_data/input/shape/cs10_basin.shp&quot; Preview: basin_shp &lt;- read_sf(basin_path) basin_map &lt;- mapview(basin_shp, alpha.region = 0, legend = FALSE) basin_map 1.4 Land object input Requirements: column id number for each element column type defining land use column drainage containing the id of the channel recieving water from the drained field. Land object polygons with attribute table. a) shows a land layer without tile drainage implemented. b) shows a case where the agricultural field with the land id = 2 has tile drainage activated and drains the tile flow into the channel id = 23 Schürz et al. (2022) The creation of the land object map was not documented. It is located here: lo_path &lt;- &quot;model_data/input/land/CS10_LU.shp&quot; A preview: lo_shp &lt;- read_sf(lo_path) lo_plot &lt;- ggplot(lo_shp) + geom_sf(mapping = aes(fill = drainage)) + sf_theme + ggtitle(&quot;CS10 Landuse map&quot;, &quot;Tile drainage indicated by ID of recieving channel&quot;) print(lo_plot) 1.4.1 Data sources Currently not documented 1.4.2 Delineation of land objects Currently not documented 1.4.3 Standing water bodies and the landuse type = ‘watr’ Currently not documented 1.4.4 Tile drainage option To determine which of our agricultural fields need drainage, we are going to use the Jordsmonn Map, specifically the Natural drainage capacity (Naturlige dreneringsforhold) described in column “JR_DREN”. Documentation for this dataset can be found here. The datasets have been clipped to the catchment area before this analysis (to reduce file sizes and computation time). jordmonn &lt;- &quot;model_data/input/soil/jordsmonn.shp&quot; jm_shp &lt;- read_sf(jordmonn) There is a lot of junk in this file (89 columns of data), we only need JR_DREN jm_shp_filt &lt;- jm_shp %&gt;% select(geometry, JR_DREN) Classes 1,2 and 3 have the need for tile drains, whereas class 4 has enough natural drainage capacity to forgo tile drainage. jm_drained &lt;- jm_shp_filt %&gt;% filter(JR_DREN != &quot;4&quot;) jm_not_drained &lt;- jm_shp_filt %&gt;% filter(JR_DREN == &quot;4&quot;) Plots: jm_plot_drain &lt;- ggplot(jm_drained) + geom_sf(mapping = aes(fill = JR_DREN))+ggtitle(&quot;Artificial Drainage Likely&quot;, &quot;With tile drainage&quot;) + sf_theme jm_plot_not_drain &lt;- ggplot(jm_not_drained) + geom_sf(mapping = aes(fill = JR_DREN))+ggtitle(&quot;Natural Drainage Likely&quot;, &quot;Presumably tile drained&quot;) + sf_theme print(jm_plot_drain) print(jm_plot_not_drain) Figure 1.2: Tile drainage Classes The drainage column of our land use map has already been defined, however every field regardless of its natural drainage class, has been assigned tile drains. We will now remove the tile drains which are located on class 4 soils. First we will drop any unneeded data in our cluttered land object map. lu_map &lt;- lo_shp %&gt;% select(geometry, id, type, drainage) And convert our drainage map to the same projection. jm_shp_filt &lt;- st_transform(jm_shp_filt, st_crs(lu_map)) Then we will join the drainage class attribute spatially. intersect_pct_4 &lt;- st_intersection(lu_map, jm_shp_filt %&gt;% filter(JR_DREN == &quot;4&quot;)) %&gt;% mutate(intersect_4 = st_area(.)) %&gt;% # create new column with shape area dplyr::select(id, intersect_4) %&gt;% # only select columns needed to merge st_drop_geometry() ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries intersect_pct_not_4 &lt;- st_intersection(lu_map, jm_shp_filt %&gt;% filter(JR_DREN != &quot;4&quot;)) %&gt;% mutate(not_4 = st_area(.)) %&gt;% # create new column with shape area dplyr::select(id, not_4) %&gt;% # only select columns needed to merge st_drop_geometry() ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries Total the individual intersectoins class_4 &lt;- intersect_pct_4 %&gt;% group_by(id) %&gt;% summarise(class_4 = sum(intersect_4)) not_class_4 &lt;- intersect_pct_not_4 %&gt;% group_by(id) %&gt;% summarise(not_class_4 = sum(not_4)) Left join them to our land use map by their ID lu_drains &lt;- left_join(lu_map, class_4, by = &quot;id&quot;) lu_drains &lt;- left_join(lu_drains, not_class_4, by = &quot;id&quot;) Set NA values to 0 lu_drains$class_4[which(lu_drains$class_4 %&gt;% is.na())] = 0 lu_drains$not_class_4[which(lu_drains$not_class_4 %&gt;% is.na())] = 0 Predefining our natural drainage attribute as false and defining our generic land use classes which are to be excluded from the manipulation. lu_drains$natural_drain = FALSE generics &lt;- c(&quot;frst&quot;,&quot;rngb&quot;,&quot;urml&quot;,&quot;utrn&quot;,&quot;past&quot;, &quot;watr&quot;, &quot;wetf&quot;) lu_drains$natural_drain[which((lu_drains$class_4 &gt;= lu_drains$not_class_4) &amp; (lu_drains$type %in% generics == FALSE))] = TRUE How many drains are we removing? removed_len &lt;- which((lu_drains$class_4 &gt;= lu_drains$not_class_4) &amp; (lu_drains$type %in% generics == FALSE)) %&gt;% length() removed_len ## [1] 238 Seems like a lot, but how many drained HRUs are there in total? total_drains &lt;- lu_map %&gt;% filter(drainage &gt; 0) %&gt;% pull(drainage) %&gt;% length() total_drains ## [1] 1947 paste(((removed_len / total_drains) * 100) %&gt;% round(1), &quot;% of drained agricultural HRUs will have their drains removed.&quot;) ## [1] &quot;12.2 % of drained agricultural HRUs will have their drains removed.&quot; Time to remove: lu_drains$drainage[which(lu_drains$natural_drain == TRUE)] = NA And drop the columns we don’t need lu_map_v2 &lt;- lu_drains %&gt;% select(geometry, id, type, drainage) Which fields are naturally drained? basin_map + mapview(lu_drains %&gt;% filter(natural_drain), zcol = &quot;type&quot;, legend = FALSE) Our land use map now looks like this. The Number value points to the channel being drained to. lu_v2 &lt;- ggplot(lu_map_v2) + geom_sf(mapping = aes(fill = drainage)) + sf_theme + ggtitle(&quot;CS10 Landuse map&quot;, &quot;Tile drainage indicated by ID of recieving channel&quot;) print(lo_plot) print(lu_v2) Figure 1.3: Tile drainage which was removed Time to save the changes: write_sf(lu_map_v2, &quot;model_data/input/land/CS10_LU_V2.shp&quot;) And cleanup rm(list = ls()) 1.4.5 Existing and potential structures to retain water and nutrients Currently not documented 1.5 Channel object input Currently not documented 1.5.1 Data sources and data processing Currently not documented 1.6 Point sources locations Currently not documented 1.7 Aquifer Objects Currently not documented References "]]
