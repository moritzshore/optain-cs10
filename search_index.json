[["measure-classification.html", "Section 17 Measure Classification 17.1 Introduction 17.2 Determining Classification 17.3 Applying Classification 17.4 HRU Scenario Table", " Section 17 Measure Classification 17.1 Introduction Our measures are too loosely grouped, making it difficult for our optimization. We are aiming to have around 500 measures, currently we have more. We will need our HRU ids spatially, as well as our Measures, erosion classes, and property register. require(sf) require(dplyr) require(mapview) require(DT) ## [1] &quot;sf 1.0.18&quot; ## [1] &quot;dplyr 1.1.4&quot; ## [1] &quot;DT 0.33&quot; Get our maps: # For measure IDs and location: lu_map &lt;- read_sf(&quot;model_data/input/land/CS10_LU.shp&quot;) # For HRU IDs: hru_map &lt;- read_sf(&quot;model_data/cs10_setup/optain-cs10/data/vector/hru.shp&quot;) # For Erosion Risk Levels: erosion_map &lt;- read_sf(&quot;model_data/input/soil/erosionriskclasses_kraakstad.shp&quot;) # For Farm ownership IDs: farm_map &lt;- read_sf(&quot;model_data/input/property/matrikkel.shp&quot;) farm_map &lt;- st_transform(farm_map, st_crs(lu_map)) Filter data lu_filter &lt;- lu_map %&gt;% select(&quot;buffer_6m_&quot;, &quot;gully&quot;, &quot;wetland&quot;, &quot;dam&quot;, &quot;type&quot;, &quot;geometry&quot;) hru_filter &lt;- hru_map %&gt;% select(&quot;name&quot;, &quot;type&quot;) erosion_filter &lt;- erosion_map %&gt;% select(&quot;A_HPKL&quot;, &quot;geometry&quot;) farm_filter &lt;- farm_map %&gt;% select(&quot;GARDSNUMME&quot;, &quot;geometry&quot;) farm_dissolved &lt;- farm_filter %&gt;% group_by(GARDSNUMME) %&gt;% summarise() erosion_dissolved &lt;- erosion_filter %&gt;% group_by(A_HPKL) %&gt;% summarise() Map Farm ID farm_dissolved$GARDSNUMME&lt;-as.factor(farm_dissolved$GARDSNUMME) farmcolors &lt;- farm_dissolved$GARDSNUMME %&gt;% unique() %&gt;% length() # samples randomizes legend myfill &lt;- hcl.colors(farmcolors, palette = &quot;Dark 3&quot;) %&gt;% sample() mapview(farm_dissolved, zcol = &quot;GARDSNUMME&quot;, legend = FALSE, col.regions = myfill) Map Erosion Classes myfill &lt;- hcl.colors(4, palette = &quot;Fall&quot;) erosion_dissolved$A_HPKL &lt;- as.factor(erosion_dissolved$A_HPKL) mapview(erosion_dissolved, zcol = &quot;A_HPKL&quot;, col.regions = myfill) Ideally the above 4 maps would have their attributes spatially joined in R, but since I cannot figure out a nice way to do that, I did it quick and nicely in QGIS: mea_map &lt;- read_sf(&quot;model_data/input/measure/measure_comola_map.shp&quot;) myfill &lt;- hcl.colors(5, palette = &quot;Fall&quot;) NA_ahpkl &lt;- mea_map$A_HPKL %&gt;% is.na() %&gt;% which() mea_map$A_HPKL[NA_ahpkl] &lt;- 0 mapview(mea_map, zcol = &quot;A_HPKL&quot;, col.regions = myfill) 17.2 Determining Classification We plan to do the following farm based classification: 70 farms in the catchment could implement gullies: gully_farms &lt;- mea_map %&gt;% filter(gully &gt; 0) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() gully_farms ## [1] 70 68 farms can implement buffers: buffer_farms &lt;- mea_map %&gt;% filter(buffer_6m_ &gt; 0) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() buffer_farms ## [1] 68 And we can implement 3 ponds. dams &lt;- mea_map %&gt;% filter(dam &gt; 0) %&gt;% pull(dam) %&gt;% unique() %&gt;% length() dams ## [1] 3 We have 501 agricultural fields to apply no-till to. non_agri &lt;- c(&quot;frst&quot;, &quot;past&quot;, &quot;rngb&quot;, &quot;urml&quot;, &quot;utrn&quot;, &quot;wetf&quot;) mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% pull(type) %&gt;% unique() %&gt;% length() ## [1] 501 If we group these by farm level, we have 82 mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() ## [1] 82 If we expand these to erosion risk, we have: class1 = mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == 1) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() class2 = mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == 2) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() class3 = mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == 3) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() class4 = mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == 4) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() class0 = mea_map %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == 0) %&gt;% pull(GARDSNUMME) %&gt;% unique() %&gt;% length() hrus_df &lt;- data.frame ( c1 = class1, c2 = class2, c3 = class3, c4 = class4, c0 = class0) DT::datatable(hrus_df) In total, that would give us 363 measures to optimize: (well under budget) class1 + # low erosion risk lowtill farms class2 + # medium erosion risk lowtill farms class3 + # high erosion risk lowtill farms class4 + # very erosion risk lowtill farms class0 + # no erosion risk lowtill farms (not mapped) gully_farms + # gully farms buffer_farms + # buffer strip farms dams # ponds ## [1] 363 17.3 Applying Classification First we need to allocate incremental IDs to the measures: class_1_alloc &lt;- c(1:class1) class_2_alloc &lt;- c((last(class_1_alloc)+1):(last(class_1_alloc)+class2)) class_3_alloc &lt;- c((last(class_2_alloc)+1):(last(class_2_alloc)+class3)) class_4_alloc &lt;- c((last(class_3_alloc)+1):(last(class_3_alloc)+class4)) class_0_alloc &lt;- c((last(class_4_alloc)+1):(last(class_4_alloc)+class0)) gully_alloc &lt;- c((last(class_0_alloc)+1):(last(class_0_alloc)+gully_farms)) buffer_alloc &lt;- c((last(gully_alloc)+1):(last(gully_alloc)+buffer_farms)) dam_alloc &lt;- c((last(buffer_alloc)+1):(last(buffer_alloc)+dams)) full_Series &lt;- c( class_1_alloc, class_2_alloc, class_3_alloc, class_4_alloc, class_0_alloc, gully_alloc, buffer_alloc, dam_alloc) full_Series %&gt;% length() # same length? ## [1] 363 (full_Series-c(1:363) == 0) %&gt;% all() # all incremental? ## [1] TRUE Now we need to translate the gardnummers to the allocated measure IDs.. 17.3.1 Gullies (grassed water ways) Measure range from 223 to 292 # Grabs the measure codes for each gully measure gully_codes &lt;- mea_map %&gt;% filter(gully &gt; 0) %&gt;% pull(gully) # grabs the farm IDs for each gully measure gully_farm_ids &lt;- mea_map %&gt;% filter(gully &gt; 0) %&gt;% pull(GARDSNUMME) # Grabs the unique farms which have gully measures gully_farm_uniq &lt;- gully_farm_ids %&gt;% unique() %&gt;% sort() # A look up table from gully farm IDs to old measure IDs mea_to_farm &lt;- data.frame(farm_id = gully_farm_ids, measure_id = gully_codes) # A look up table from farm IDs which have gullies, to the gully-allocated IDs farm_to_alloc &lt;- data.frame(farm_id = gully_farm_uniq, gully_alloc = gully_alloc) # A look up table combined from previous two lookup &lt;- left_join(farm_to_alloc,mea_to_farm, by = &quot;farm_id&quot;, keep = FALSE, ) ## Re-coding IDs # https://stackoverflow.com/questions/66231321/recode-values-based-on-look-up-table-with-dplyr-r gully_df = mea_map %&gt;% st_drop_geometry %&gt;% filter(gully &gt; 0) %&gt;% select(id, name, GARDSNUMME, gully) recode_vec &lt;- lookup$gully_alloc names(recode_vec) &lt;- lookup$measure_id # reclassifying gully_reclassed &lt;- gully_df %&gt;% mutate(gully_new = recode(gully, !!!recode_vec)) datatable(gully_reclassed) 17.3.2 Buffer Strips Same procedure, measure IDs 293 to 360 # Grabs the measure codes for each buffer_6m_ measure buffer_codes &lt;- mea_map %&gt;% filter(buffer_6m_ &gt; 0) %&gt;% pull(buffer_6m_ ) # grabs the farm IDs for each buffer measure buffer_farm_ids &lt;- mea_map %&gt;% filter(buffer_6m_ &gt; 0) %&gt;% pull(GARDSNUMME) # Grabs the unique farms which have buffer_6m_ measures buffer_farm_uniq &lt;- buffer_farm_ids %&gt;% unique() %&gt;% sort() # A look up table from buffer farm IDs to old measure IDs mea_to_farm &lt;- data.frame(farm_id = buffer_farm_ids, measure_id = buffer_codes) # A look up table from farm IDs which have buffers, to the buffer-allocated IDs farm_to_alloc &lt;- data.frame(farm_id = buffer_farm_uniq, buffer_alloc = buffer_alloc) # A look up table combined from previous two lookup &lt;- left_join(farm_to_alloc,mea_to_farm, by = &quot;farm_id&quot;, keep = FALSE, ) ## Recoding IDs # https://stackoverflow.com/questions/66231321/recode-values-based-on-look-up-table-with-dplyr-r buffer_df = mea_map %&gt;% st_drop_geometry %&gt;% filter(buffer_6m_ &gt; 0) %&gt;% select(id, name, GARDSNUMME, buffer_6m_) recode_vec &lt;- lookup$buffer_alloc names(recode_vec) &lt;- lookup$measure_id # reclassifiying buffer_reclassed &lt;- buffer_df %&gt;% mutate(buffer_new = recode(buffer_6m_, !!!recode_vec)) datatable(buffer_reclassed) 17.3.3 Ponds # Grabs the measure codes for each dam measure pond_codes &lt;- mea_map %&gt;% filter(dam &gt; 0) %&gt;% pull(dam) # grabs the farm IDs for each pond measure pond_farm_ids &lt;- mea_map %&gt;% filter(dam &gt; 0) %&gt;% pull(GARDSNUMME) # Grabs the unique farms which have pond measures pond_farm_uniq &lt;- pond_farm_ids %&gt;% unique() %&gt;% sort() # A look up table from pond farm IDs to old measure IDs mea_to_farm &lt;- data.frame(farm_id = pond_farm_ids, measure_id = pond_codes) # A look up table from farm IDs which have gullies, to the pond-allocated IDs farm_to_alloc &lt;- data.frame(farm_id = pond_farm_uniq, pond_alloc = dam_alloc) # A look up table combined from previous two lookup &lt;- left_join(farm_to_alloc,mea_to_farm, by = &quot;farm_id&quot;, keep = FALSE, ) ## Re-coding IDs # https://stackoverflow.com/questions/66231321/recode-values-based-on-look-up-table-with-dplyr-r pond_df = mea_map %&gt;% st_drop_geometry() %&gt;% filter(dam &gt; 0) %&gt;% select(id, name, GARDSNUMME, dam) recode_vec &lt;- lookup$pond_alloc names(recode_vec) &lt;- lookup$measure_id # reclassifying pond_reclassed &lt;- pond_df %&gt;% mutate(pond_new = recode(dam, !!!recode_vec)) datatable(pond_reclassed) 17.3.4 NoTill (management measure) Re-classify for each erosion risk level custom_reclass &lt;- function(mea_map, erosion_class, mea_alloc) { non_agri &lt;- c(&quot;frst&quot;, &quot;past&quot;, &quot;rngb&quot;, &quot;urml&quot;, &quot;utrn&quot;, &quot;wetf&quot;) # farm codes of farms with class 1 erosion agricultural fields. relevant_data &lt;- mea_map %&gt;% st_drop_geometry %&gt;% filter((type %in% non_agri) == FALSE) %&gt;% filter(A_HPKL == erosion_class) %&gt;% select(id, name, GARDSNUMME, type) class_X_farms &lt;- relevant_data$GARDSNUMME %&gt;% unique() %&gt;% sort() class_X_hrus &lt;- relevant_data$id %&gt;% unique() %&gt;% sort() recode_vec &lt;- mea_alloc names(recode_vec) &lt;- class_X_farms # reclassifying class_X_reclass &lt;- relevant_data %&gt;% mutate(notill = recode(GARDSNUMME, !!!recode_vec)) return(class_X_reclass) } notill_1 &lt;- custom_reclass(mea_map, erosion_class = 1, mea_alloc = class_1_alloc) notill_2 &lt;- custom_reclass(mea_map, erosion_class = 2, mea_alloc = class_2_alloc) notill_3 &lt;- custom_reclass(mea_map, erosion_class = 3, mea_alloc = class_3_alloc) notill_4 &lt;- custom_reclass(mea_map, erosion_class = 4, mea_alloc = class_4_alloc) notill_0 &lt;- custom_reclass(mea_map, erosion_class = 0, mea_alloc = class_0_alloc) # notill_4$measure_id %&gt;% unique() %&gt;% length() == 10 # check datatable(notill_3) Merge into single dataframe full_notill &lt;- rbind((notill_1 %&gt;% select(name, notill)), (notill_2 %&gt;% select(name, notill)), (notill_3 %&gt;% select(name, notill)), (notill_4 %&gt;% select(name, notill)), (notill_0 %&gt;% select(name, notill))) full_notill &lt;- full_notill[order(full_notill$name),] datatable(full_notill) 17.4 HRU Scenario Table We now need to generate the scenario HRU table for COMOLA. Find source code here: UFZ-CLOUD library(sf) library(data.table) library(stringr) library(tidyverse) ## [1] &quot;sf 1.0.18&quot; ## [1] &quot;data.table 1.16.2&quot; ## [1] &quot;stringr 1.5.1&quot; ## [1] &quot;tidyverse 2.0.0&quot; # all OPTAIN measures measures_optain &lt;- data.frame(&#39;nswrm_code&#39; = c(&#39;buffer&#39;, &#39;edgefilter&#39;, &#39;hedge&#39;, &#39;grassslope&#39;, &#39;grassrchrg&#39;, &#39;pond&#39;, &#39;afforest&#39;, &#39;floodres&#39;, &#39;channres&#39;, &#39;swale&#39;, &#39;wetland&#39;, &#39;cdrain&#39;, &#39;terrace&#39;, &#39;notill&#39;, &#39;lowtill&#39;, &#39;lowtillcc&#39;, &#39;mulching&#39;, &#39;subsoiling&#39;, &#39;rotation&#39;, &#39;intercrop&#39;, &#39;covercrop&#39;, &#39;earlysow&#39;, &#39;droughtplt&#39;), &#39;description&#39; = c(&#39;Riparian buffers&#39;, &#39;Edge-of-field filter strips&#39;, &#39;Hedges/Field division&#39;, &#39;Grasland cover on erosive slopes&#39;, &#39;Grasland cover in recharge area&#39;, &#39;Retention/detention ponds&#39;, &#39;Afforestation&#39;, &#39;Floodplain restoration&#39;, &#39;Channel restoration&#39;, &#39;Swales&#39;, &#39;Constructed wetlands&#39;, &#39;Controlled drainage&#39;, &#39;Terracing&#39;, &#39;No-till agriculture&#39;, &#39;Low-till agriculture&#39;, &#39;Low-till agriculture combined with cover crops&#39;, &#39;Mulching&#39;, &#39;Subsoiling&#39;, &#39;Crop rotation&#39;, &#39;Intercropping&#39;, &#39;Green cover/ catch crops&#39;, &#39;Early sowing&#39;, &#39;Drought-resistant plants&#39;)) datatable(measures_optain) 17.4.1 Merging into Landuse Map “The land use shapefile must include columns for each measure (names according to the list above!). For each measure the id (as integer) of potential sites for implementation must be given. Multiple hrus can have the same measure id, e.g. if an individual grassed waterway consists of multiple hrus. If two individual measures of the same type (e.g. two crossing grassed waterways) occur on the same hru, provide both ids separated by ’_‘, e.g. ’5_6’ (see also example data). Define NA in case there is no potential site for a measure (please study the example lu shapefile)” For our case, we do not need to consider the 5_6 thing as we have no doubled same-measure groupings. Lessons learned: In the future if we would want to do scenarios on ie. the length of the grassed water ways, or the width of the buffer strips, we would have to incorporate this 5_6 thing. lu_mea &lt;- mea_map %&gt;% select(name, type) lu_mea &lt;- left_join(lu_mea, buffer_reclassed %&gt;% select(name, buffer = buffer_new), by= &quot;name&quot;) lu_mea &lt;- left_join(lu_mea, gully_reclassed %&gt;% select(name, grassslope = gully_new), by= &quot;name&quot;) lu_mea &lt;- left_join(lu_mea, pond_reclassed %&gt;% select(name, pond = pond_new), by= &quot;name&quot;) lu_mea &lt;- left_join(lu_mea, full_notill, by= &quot;name&quot;) lu_mea &lt;- lu_mea %&gt;% select(type, grassslope, notill, buffer, pond, geometry) write_sf(lu_mea, &quot;model_data/input/measure/lu_measures_COMOLA.shp&quot;) lu_mea %&gt;% st_drop_geometry() %&gt;% datatable() Now to use the provided script to generate the measure_location_cs10.csv lu_shp &lt;- &quot;model_data/input/measure/lu_measures_COMOLA.shp&quot; hru_shp &lt;- &quot;model_data/cs10_setup/optain-cs10/data/vector/hru.shp&quot; # generate scenario hru table (just run the code)-------------------------- is.integer0 &lt;- function(x) { is.integer(x) &amp;&amp; length(x) == 0L } # read in shapefiles lu &lt;- read_sf(lu_shp) hru_swat &lt;- read_sf(hru_shp) # assign measures to SWAT+ hru names lu_swat &lt;- st_drop_geometry(st_join(hru_swat, lu, largest=T)) ## Warning: attribute variables are assumed to be spatially constant throughout ## all geometries hru &lt;- data.frame(&#39;hru&#39;=lu_swat$name) # generate hru-scenario table meas.col &lt;- which(colnames(lu_swat) %in% measures_optain$nswrm_code) hru_scn &lt;- data.frame(&#39;hru&#39;=NA, &#39;nswrm&#39;=NA, &#39;name&#39;=NA) for(i in 1:length(meas.col)){ idx &lt;- which(!is.na(lu_swat[,meas.col[i]])) meas_ &lt;- colnames(lu_swat)[meas.col[i]] hru_ &lt;- hru hru_$nswrm &lt;- NA hru_$nswrm[idx] &lt;- meas_ hru_$name &lt;- NA hru_$name[idx] &lt;- paste0(meas_,&#39;_&#39;, as.matrix(lu_swat[idx,meas.col[i]])) # different grassed waterways on the same hru? multiple &lt;- which(str_count(hru_$name, &quot;_&quot;) &gt; 1) if(!is.integer0(multiple)){ scn_multiple &lt;- str_split_fixed(hru_$name[multiple],&quot;_&quot;,3) hru_$name[multiple] &lt;- paste0(meas_,&#39;_&#39;,scn_multiple[,2]) hru_add &lt;- data.frame(&#39;hru&#39; = hru_$hru[multiple], &#39;nswrm&#39; = meas_, &#39;name&#39; = paste0(meas_,&#39;_&#39;,scn_multiple[,3])) hru_ &lt;- rbind.data.frame(hru_, hru_add) } hru_ &lt;- hru_[-which(is.na(hru_$name)),] hru_scn &lt;- rbind.data.frame(hru_scn, hru_) } hru_scn &lt;- hru_scn[-1,] hru_scn$obj_id &lt;- as.numeric(substr(hru_scn$hru,4,nchar(hru_scn$hru))) hru_scn2 &lt;- hru_scn %&gt;% group_by(name, nswrm) %&gt;% summarize(obj_id = paste(sort(unique(obj_id)),collapse=&quot;, &quot;)) ## `summarise()` has grouped output by &#39;name&#39;. You can override using the ## `.groups` argument. hru_scn2$id &lt;- c(1:length(hru_scn2$name)) hru_scn2 &lt;- hru_scn2[,c(4,1,2,3)] # write hru-scenario table write_csv(hru_scn2, &#39;model_data/input/measure/measure_location_CS10.csv&#39;, quote = &quot;needed&quot;, na = &#39;&#39;) # admire our result: hru_scn2 %&gt;% datatable() # clean up for next chapter rm(list=ls()) "]]
