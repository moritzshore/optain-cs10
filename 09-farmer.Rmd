# SWATFarmR Management Schedules

WIP: Every field in the OPTAIN SWAT setup needs its own management. We will
use the SWATFarmR package to define it. 

```{r}
run_this_chapter = FALSE
```


**Pre-requirements**

The creation of management schedules with `SWATfarmR` requires a SWAT+
model setup created by the `SWATbuildR` package.

We also require the following packages:

```{r, message=FALSE}
require(DT)
require(ggplot2)
require(readr)
require(stringr)
require(magrittr)
#remotes::install_github("chrisschuerz/SWATfarmR")
require(SWATfarmR)
```


## Pre-processing crop rotation

This OPTAIN-provided workflow pre-processes our crop rotation data into a
`SWATfarmR` compatible format. Authored by Michael Strauch, modified by 
Moritz Shore

It requires the following packages

```{r, message=FALSE}
require(sf)
require(tidyverse)
require(lubridate)
require(reshape2)
require(remotes)
require(dplyr)
require(data.table)
require(DT)
```

And the following functions:
```{r}
source('model_data/swat_farmR/functions_write_SWATfarmR_input.R')
```

### Input files

#### Land use map with crop information

This map has the following requirements:

1. The map must contain the land use of each hru. In case of cropland, the names
must be unique for each field (e.g., 'field_1', 'field_2', etc.)

2. The map must also contain crop infos for the period 1988 to 2020 (or 2021 if
crop info available). This requires an extrapolation of the available crop
sequences (the sequences derived from remote-sensing based crop classification
or local data).

3. The extrapolated crop sequence for 33 years will be also used for running
climate scenarios and must not contain any gaps. That means, gaps have to be
closed manually!

4. The year columns must be named y_1988, y_1989, etc.

5. The crop infos for each year must match the crop_mgt names in the management
operation schedules (provided in a .csv file, see below)

see also section 4.1 of the modelling protocol (ref)


```{r}
lu_shp <- 'model_data/input/crop/land_with_cr.shp'

lu <- st_drop_geometry(read_sf(lu_shp))

datatable(
  lu %>% head(50),
  extensions = "Scroller",
  options = list(scrollY = 200, scroller = TRUE)
)
```

#### Management operation schedules for each crop

..or, if available, crop-management type.

1. All schedules must be compiled in one csv file (see example in demo data and
study also section 4.2 of the modelling protocol)

2. 'crop_mgt' must start with the 4-character SWAT crop names (any further
management specification is optional).

3. Each schedule must contain a 'skip' line to indicate the change of years.

4. The 'skip' line should never be the last line of a schedule.

```{r}
mgt_csv <- 'model_data/input/management/mgt_crops_CS10.csv'

mgt_crop <- read.csv(mgt_csv)

datatable(mgt_crop,
          extensions = "Scroller",
          options = list(scrollY = 200, scroller = TRUE))
```

#### Management operation schedules for generic land-use classes

Usually all non-cropland classes with vegetation cover

1. here, all schedules must be provided already in the SWATfarmR input format.

```{r}
lu_generic_csv <- 'model_data/input/management/farmR_generic_CS10.csv' # generic land use management .csv table

mgt_generic <- read.csv(lu_generic_csv)

datatable(mgt_generic)
```

### Settings

#### Simulation Period

```{r}
start_y <- 2010 # starting year (consider at least 3 years for warm-up!)
end_y <- 2020 # ending year
```

#### Prefix of cropland hrus 

> all names of hrus with a crop rotation must begin with this prefix in column
'lu' of your land use 

```{r}
hru_crops <- 'a_'
```

#### Multi-year farmland grass

Did you define any multi-year farmland grass schedules? 'y' (yes), 'n' (no)

```{r}
m_yr_sch_existing <- 'n'
```

If yes, define also the following variables. **If not, skip next four lines**
```{r}
crop_myr <- 'past' # name of your farmland grass
```

Maximum number of years farmland grass can grow before it is killed (should be
<8)
```{r}
max_yr <- 5
```

Do your multi-year farmland grass schedules consider the type of the following
crop (summer or winter crop)?

(e.g., a '_1.5yr' schedule with a kill op in spring allows for planting a summer
crop immediately afterwards)

If yes, you must define your summer crops

```{r}
crop_s <- c('sgbt','csil','barl')
```

Do your summer crop schedules usually start with an operation in autumn (e.g.
tillage)? To combine them with farmland grass, it is necessary that you provide
'half-year-schedules' ('half-year-schedules' are additional summer crop
schedules without operations in autumn) The adapted schedules should be added to
the crop management table with suffix '_0.5yr' (e.g. 'csil_0.5yr')


If additional 'half-year-schedules' are not needed, because your normal summer
crop schedules do not start in autumn, type 'n'

```{r}
additional_h_yr_sch_existing <- 'n' # 'y' (yes), 'n' (no)
```

### Checks

Check for correct positioning of 'skip' line

```{r, eval = run_this_chapter}
check_skip <- check_skip_position()
```

Check for date conflicts in single crop schedules

```{r, eval = run_this_chapter}
check_date_conflicts1()
```

Build schedules for crop sequences (Messages disabled)

```{r, results='hide', eval = run_this_chapter}
rota_schedules <- build_rotation_schedules()
```

Check for date conflicts in the full rotation schedule. (Messages disabled)

```{r results='hide', warning=TRUE, eval = run_this_chapter}
check_date_conflicts2()
```

Solve minor date conflicts (where only a few days/weeks are overlapping)

(Messages disabled)

```{r results='hide', warning=TRUE, eval = run_this_chapter}
rota_schedules <- solve_date_conflicts()
```

Check again for date conflicts (Messages disabled)

```{r results='hide', warning=TRUE, eval = run_this_chapter}
check_date_conflicts2()
```

### Writing input data

Write the SWAT farmR input table 
```{r, eval = run_this_chapter}
write_farmR_input()
```

The output of this pre-processing stage is loaded in from this file:

```{r}
farmR_input <- readr::read_csv("model_data/input/management/farmR_input.csv",
                               show_col_types = F)

datatable(
  head(farmR_input, 50),
  extensions = "Scroller",
  options = list(scrollY = 200, scroller = TRUE)
)
```

TODO: Figure out why this is an issue. Are you using the wrong buildR output
as source material for the crop generation?

We need to fix the land use name, which entails replacing the `_drn_lum`
with just `_lum` for all the agricultural fields. This is because
`land.shp` from buildR does not include the `_drn` for some reason

```{r}

# TODO: Figure out why this is an issue. Are you using the wrong buildR output
# as source material for the crop generation?
  
 farmR_input2 <- farmR_input %>% filter(grepl(x = land_use, "a_")) %>%
   mutate(land_use = str_replace(.$land_use, "_lum", "_drn_lum"))
 
 farmR_input3 <- farmR_input %>% filter(!grepl(x = land_use, "a_"))
 
 farmR_input4 <- rbind(farmR_input2, farmR_input3)
 
 write_csv(farmR_input4, file ="model_data/input/management/farmR_input2.csv")
 
 rm(farmR_input, farmR_input2, farmR_input3, farmR_input4)

# Yes I am aware that code is bad and ugly.
```

## Initializing FarmR

If the FarmR has never been initialized, then use `new_farmr()` and
`read_management()`, otherwise `load_farmr()`.

EVAL FALSE as BuildR script is still broken

```{r, eval = run_this_chapter}
project_path <- "model_data/cs10_setup/swat_farmr/"

SWATfarmR::new_farmr(project_name = "cs10", project_path = project_path )

#load_farmr(...)

cs10$read_management(file = "model_data/input/management/farmR_input2.csv")
```

## Calculating Antecedent Precipitation Index

TODO loading API from section REF
```{r, eval=run_this_chapter}
# using temp API

# TODO add real API

# Load dplyr. We will use functions such as 'mutate' and 'select'.
library(dplyr)
# Extract the precipitation from the farmr project
pcp <- cs10$.data$variables$pcp

# Extract the hydrologic soil group values for all HRUs
hsg <- select(cs10$.data$meta$hru_attributes, hru, hyd_grp)

# Calculate api values for the hsg classes A to D
api_A <- variable_decay(variable = pcp, n_steps = -5, decay_rate = 1)
api_B <- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.8)
api_C <- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.7)
api_D <- variable_decay(variable = pcp, n_steps = -5, decay_rate = 0.5)

# Bind the data together into one api table and name them with the hsgs
api <- bind_cols(api_A, api_B, api_C, api_D)
names(api) <- c('api_A', 'api_B', 'api_C', 'api_D')

# To add the variable to the farmR you have to tell it which variables are
# assigned to which HRUs
hru_asgn <- mutate(hsg, api = paste0('api_', hyd_grp)) %>% select(hru, api)
  
# Add the variable api to the farmR project
cs10$add_variable(data = api, name = 'api', assign_unit = hru_asgn, overwrite = T)

```


....

## Scheduling Operations

```{r, eval=run_this_chapter}

cs10$schedule_operations(start_year = 2016, end_year = 2019, n_schedule = 2)
```

### Write Operations

We cannot write from 1988 as it is limited to our climate data, which currently
only spans back to 2010

```{r, eval=run_this_chapter}
cs10$write_operations(start_year = 2016, end_year = 2019)

```
The following files have been updated:

- file.cio

- hru-data.hru

-landuse.lum

- management.sch

- plant.ini

These need to overwrite the older files in the run_swat directory. 




