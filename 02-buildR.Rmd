# Model setup with SWATBuildR

The OPTAIN project is using the COCOA approach [@schürz2022] and as such, needs to use the `SWATBuildR` package to build the SWAT+ model setup and calculate the connectivity between HRUs in the catchment. This chapter covers this process.

We will define the location of our project here:

```{r, projectpath}
project_path <- 'model_data/cs10_setup'
```

And give it the name:

```{r, projname}
project_name <- 'optain-cs10'
```

We will need the following packages for this chapter:

```{r, libraries, message=FALSE}
require(mapview)
require(sf)
require(raster)
require(dplyr)
require(ggplot2)
```

This is a custom theme we will use in many GGplots:

```{r}
sf_theme <- theme(axis.text.x=element_blank(), #remove x axis labels
        axis.ticks.x=element_blank(), #remove x axis ticks
        axis.text.y=element_blank(),  #remove y axis labels
        axis.ticks.y=element_blank()  #remove y axis ticks
        )
```

If this flag is set to true, the following code will actually run buildR, which could take about 4 hours!

```{r}
run_code = FALSE
```

## Processing input data

SWATBuildR reads input data, performs some checks on it, and saves it in a compatible format for subsequent calculations. Little documentation exists on the creation of these data sets. IF you have any information to add, feel free to do so!

### High-Resolution Digital Elevation Model (DEM)

The high-resolution DEM is the basis for calculation of water connectivity, among other things. Most of the documentation of the creation of the DEM for CS10 has been lost to the sands of time. All we know is that it is located here:

```{r, dempath}
dem_path <- "model_data/input/elevation/dtm3_ns_v5.tif"
```

```{r, plotdemraster, message=FALSE, fig.align = "center", fig.cap="CS10 Digital elevation model (DEM)."}
plot(raster(dem_path))
```

To our knowledge, it has a 10 meter resolution. 1 meter resolution was available but there seems to have been issues with using it. It is definitely preferable to use the 1m DEM as certain important information can be lost with (max allowed resolution) of 10m.

![An example of a hydrologically effective landscape features being lost due to coarse DEM resolution. From [@schürz2022]](figures/1mdemvs10.png)

### Processing the Basin Boundary

The basin boundary has presumably been created using the defined outlet point of the catchment and the DEM. No more is currently known about this file other than that it is located here:

```{r, boundpath}
bound_path <- "model_data/input/shape/cs10_basin.shp"
```

```{r, watershedplot, message=FALSE, echo=FALSE, eval=TRUE, fig.align='center', fig.cap="CS10 Basin, caclulated from the DEM."}
bound_sf <- read_sf(bound_path)

basin <- ggplot(bound_sf) + geom_sf() + sf_theme

print(basin)
```

We will begin using the `SWATBuildR` Package by initializing its functions. (Note: this package is currently unfinished, which is why this step is necessary).

The following code and commentary is from version `1.5.12`, written by Christoph Schuerz.

Another note: there are currently issues with White box which are being resolved.

```{r, sourceBuildRinit, message=FALSE, eval=run_code}
source('model_data/swat_buildR/init.R')
```

BuildR recommends all layers to be in the same CRS, if we set `project_layer` to `FALSE`, it will throw an error when this is not the case:

> The input layers might be in different coordinate reference systems (CRS). It is recommended to project all layers to the same CRS and check them before using them as model inputs. The model setup process checks if the layer CRSs differ from the one of the basin boundary. By setting 'proj_layer \<- TRUE' the layer is projected if the CRS is different. If FALSE different CRS trigger an error.

```{r, projlayerbool}
project_layer <- TRUE
```

We read in and check the basin boundary and run some checks

```{r, checkbound, eval=run_code}
bound <- read_sf(bound_path) %>% select()
set_proj_crs(bound, data_path)
check_polygon_topology(layer = bound, data_path =  data_path, label = 'basin', 
                       n_feat = 1, checks = c(F,T,T,T,F,F,F,F))
```

### Processing the Land layer

Our land layer is located here:

```{r, landpath}
land_path <- "model_data/input/land/CS10_LU.shp"
```

Documentation on its creation does not exist.

```{r, maplanduse, message=F, echo=F, fig.align='center', fig.cap="Land use map of CS10 by Farm ID"}
lu_shp <- read_sf(land_path)

lu_map <- ggplot(lu_shp) + geom_sf(aes(fill = type)) + sf_theme +
  theme(legend.position = "none")

print(lu_map)

```

We had an issue with the classification of the land uses. For the OPTAIN project, all agricultural fields must have a unique ID, and our land uses only had the ID of the given farm `KGB` (which had many different fields). To remedy this, new IDs were generated with the format `a_###f_#` where `a_` represents the farm, and `f_` represents the respective field of that farm. The farm names needed to be shortened because the SWAT+ model often cannot handle long ID names (longer than 16 characters)

Note, the potential measures polygons were not counted as individual fields, which is why `SP_ID` does not match up with `field_ID` -- This is by design.

```{r paged.print=TRUE}
readr::read_csv("model_data/farm_id/a_f_id.csv", show_col_types = F) %>% head()
```

This was done in a simple QGIS workflow of dissolving by farm, splitting from single part to multipart, and then adding an iterating ID per farm field. This workflow could be replicated in R, and then shown here. It is under consideration...

BuildR will now run some checks on our land layer.

```{r, check_layer_attributes1, eval=run_code}
land <- read_sf(land_path) %>% 
  check_layer_attributes(., type_to_lower = FALSE) %>%
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'land', type = 'vector')

check_polygon_topology(layer = land, data_path =  data_path, label = 'land', 
                       area_fct =  0.00, cvrg_frc = 99.9,
                       checks = c(T,F,T,T,T,T,T,T))
```

BuildR splits the land layer into HRU (land) and reservoir (water) objects

```{r, split_land_layer, eval=run_code}
split_land_layer(data_path)
```

### Processing the Channels

No documentation exists on the creation of the channels layer, all we know is that it is located here:

```{r, channel_plot, fig.cap="CS10 Channels, including surface and subsurface channels", fig.align='center'}
channel_path <- 'model_data/input/line/cs10_channels.shp'
channels <- read_sf(channel_path) %>% dplyr::select("type")

channel_map <- ggplot() + geom_sf(data = bound_sf) + 
  geom_sf(data = channels, mapping = aes(color = type)) + sf_theme

channel_map

```

BuildR runs some checks:

```{r, channelcheck, eval=run_code}
 channel <- read_sf(channel_path) %>% 
    check_layer_attributes(., type_to_lower = TRUE) %>% 
    check_project_crs(layer = ., data_path =  data_path,
                      proj_layer = project_layer, 
                      label = 'channel', type = 'vector')

check_line_topology(layer = channel, data_path = data_path,
                    label = 'channel', length_fct = 0, can_cross = FALSE)
```

BuildR then checks the connectivity between the channels and reservoirs. For this we need to define our `id_cha_out` and `id_res_out`.

"Variable `id_cha_out` sets the outlet point of the catchment. Either define a channel OR a reservoir as the final outlet. If channel then assign `id_cha_out` with the respective id from the channel layer. If reservoir then assign the respective id from the land layer to id_res_out, otherwise leave as `NULL`"

```{r, chaidout}
id_cha_out <- 37
id_res_out <- NULL
```

Running connectivity checks between channels and reservoirs:

```{r, check_cha_res_connectivity, eval=run_code}
check_cha_res_connectivity(data_path, id_cha_out, id_res_out)
```

Checking if any defined channel ids for drainage from land objects do not exist

```{r, check_land_drain_ids, eval=run_code}
check_land_drain_ids(data_path)
```

### Processing the DEM

BuildR loads and checks the DEM, and saves it.

```{r, procDEM, message=TRUE, eval=run_code}
dem <- rast(dem_path) %>% 
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'dem', type = 'raster')

check_raster_coverage(rst = dem, vct_layer = 'land', data_path = data_path, 
                      label = 'dem', cov_frc = 0.95)

save_dem_slope_raster(dem, data_path)
```

### Processing soil data

Our soil map is located here:

```{r, soil_layer_path}
soil_layer_path  <- 'model_data/input/soil/soil_layer.tif'
```

No documentation exists on its creation.

```{r soilrastermapplot, fig.align='center', fig.cap="CS10, message=FALSE, warning=FALSE, soilmapraster, echo=F}
plot(raster(soil_layer_path))
```

The soil data and look-up path are located here:

```{r, soil_lookup_path}
soil_lookup_path <- 'model_data/input/soil/soil_lookup.csv'
soil_data_path   <- 'model_data/input/soil/UserSoil_Krakstad.csv'
```

Not much documentation exists here either. Some can be found in the excel sheet:

`~/model_data/input/soil/swatsoil2.xlsx`

BuildR reads in the soil data, performs checks, processes, and saves.

NOTE: THIS IS CURRENTLY BROKEN, WITH ERROR MESSAGE:

> Warning: Cannot find coordinate operations from `EPSG:2583` ["unnamed",EDATUM[""], CS[Cartesian,2], AXIS["(E)", east, ORDER[1], LENGTHUNIT["unknown", 1]], AXIS["(N)", north, ORDER[2], LENGTHUNIT["unknown", 1]]]' (GDAL error 6) Error: [project] Cannot do this transformation

```{r, checksoil1, eval=run_code}
soil <- rast(soil_layer_path) %>% 
  check_project_crs(layer = ., data_path =  data_path, proj_layer = project_layer, 
                    label = 'soil', type = 'raster')
check_raster_coverage(rst = soil, vct_layer = 'hru', data_path = data_path, 
                      label = 'soil', cov_frc = 0.75)
# BROKEN
save_soil_raster(soil, data_path)


```

BuildR then generates a table with aggregated elevation, slope, soil for HRU units.

```{r, aggregate_hru_dem_soil}
# waiting on soil fix. 
#aggregate_hru_dem_soil(data_path)
```

Read and prepare the soil input tables and a soil/hru id table and write them into `data_path/tables.sqlite`

```{r, build_soil_data}
#build_soil_data(soil_lookup_path, soil_data_path, data_path)
```

## Calculating Contiguous Object Connectivity

SWATBuildR follows COCOA. This section contains the calculations. You can read more about it in the protocol (ref).

### Calculating land unit connectivity

Preparing raster layers based on the DEM and the surface channel objects that will be used in the calculation of the land object connectivity.

```{r, prepare_terrain_land}
#prepare_terrain_land(data_path)
```

The connection of each land object to neighboring land and water objects is calculated based on the flow accumulation and the D8 flow pointer along the object edge

```{r, calculate_land_connectivity}
# calculate_land_connectivity(data_path)
```

#### Eliminate land object connections with small flow fractions:

For each land object the flow fractions are compared to connection with the largest flow fraction of that land object. Connections are removed if their fraction is smaller than `frc_thres` relative to the largest one.

This is necessary to:

1.  Simplify the connectivity network

2.  To reduce the risk of circuit routing between land objects. Circuit routing will be checked.

If an error due to circuit routing is triggered, then 'frc_thres' must be increased to remove connectivities that may cause this issue.

```{r, frc_thres}
frc_thres <- 0.3
```

The remaining land object connections are analyzed for infinite loop routing. For each land unit the connections are propagated and checked if the end up again in the same unit.

```{r, reduce_land_connections}
#reduce_land_connections(data_path, frc_thres) %>% 
#  check_infinite_loops(., data_path, 'Land')
```

If infinite loops were identified this routine tries to resolve the issues by selectively removing connections between land units in order to get rid of all infinite loops.

```{r, resolve_loop_issues}
# resolve_loop_issues(data_path)
```

### Calculating channel/reservoir connectivity

#### Calculating the water object connectivity

the function returns the `cha` and `res` `con_out` tables in SWAT+ database format and writes them into `data_path/tables.sqlite`

```{r, build_water_object_connectivity}
#build_water_object_connectivity(data_path)
```

### Checking the water objects for infinite loops

From the cha_res_con_out tables id_from/id_to links are generated and checked for infinite loop routing.

```{r, prepare_water_links}
#prepare_water_links(data_path) %>% 
#  check_infinite_loops(., data_path, 'Water', Inf)
```

### Terrain properties

Calculate terrain properties such as elevation, slope, catchment area, channel width/depth for channel and reservoir objects and write them into `data_path/tables.sqlite`

```{r, prepare_terrain_water}
#prepare_terrain_water(data_path)
```

## Generate SWAT+ input

### Generate land object SWAT+ input tables

Build the `landuse.lum` and a landuse/hru id table and write them into `data_path/tables.sqlite`

```{r, build_landuse}
#build_landuse(data_path)
```

Build the HRU SWAT+ input files and write them into `data_path/tables.sqlite`

```{r, build_hru_input}
#build_hru_input(data_path)
```

Add wetlands to the HRUs and build the wetland input files and write them into `data_path/tables.sqlite`

(TODO fix this!)

```{r, wetland_landuse}
wetland_landuse <- c('wehb', 'wetf', 'wetl', 'wetn')
```

```{r, add_wetlands}
#add_wetlands(data_path, wetland_landuse)
```

### Generate water object SWAT+ input tables

Build the SWAT+ cha input files and write them into `data_path/tables.sqlite`

```{r, build_cha_input}
#build_cha_input(data_path)
```

Build the SWAT+ res input files and write them into `data_path/tables.sqlite`

```{r, build_res_input}
#build_res_input(data_path)
```

Build SWAT+ routing unit con_out based on 'land_connect_fraction'.

```{r, build_rout_con_out}
#build_rout_con_out(data_path)
```

Build the SWAT+ rout_unit input files and write them into `data_path/tables.sqlite`

```{r, build_rout_input}
#build_rout_input(data_path)
```

Build the SWAT+ LSU input files and write them into `data_path/tables.sqlite`

```{r, build_ls_unit_input}
#build_ls_unit_input(data_path)
```

### Build aquifer input

Build the SWAT+ aquifer input files for a single aquifer for the entire catchment. The connectivity to the channels with geomorphic flow must be added after writing the txt input files. **This is not implemented in the script yet.**

```{r, build_single_aquifer_files}
#build_single_aquifer_files(data_path)
```

## Add point source inputs

The point source locations are provided with a point vector layer in the path 'point_path'.

```{r, point_path}
point_path <- 'model_data/input/point/cs10_pointsource.shp'
```

```{r, pointsoucemap, fig.align='center', fig.cap="CS10 Point Sources, colored by Phosphorous emission and sized by Nitrogen emission"}
point_sf <- read_sf(point_path)
point_map <- mapview(point_sf, zcol = "GRAD_P", cex = "GRAD_N")

mapview(bound_sf, alpha.regions = 0.2)+point_map


```

Map of point sources, colored by (assumed) phosphorous and size by (assumed) Nitrogren

Maximum distance of a point source to a channel or a reservoir to be included as a point source object (recall) in the model setup:

```{r, max_point_dist}
max_point_dist <- 500 #meters
```

Point source records can automatically be added from files in the same folder as the point source location layer. To be identified as point source data the files must be named as `<name>_<interval>.csv`, where `<name>` must be the name of a point `int` the vector layer and `<interval>` must be one of `const`, `yr`, `mon`, or `day` depending on the time intervals in the input data.

```{r, add_point_sources}
#add_point_sources(point_path, data_path, max_point_dist)
```

## Create SWAT+ sqlite database

### Write the SWAT+Editor project database

The database will be located the 'project_path'. After writing the database it can be opened and edited with the SWAT+Editor.

```{r, create_swatplus_database}
#create_swatplus_database(project_path, project_name)
```

The next step involves you entering the SWAT+ Editor and parameterizing the model from there. These are the steps we have taken, with screenshots since it is currently not possible to replicate this process in R.

### TODO

Switch to SWAT+Editor for further model parametrization and continue with the step below after writing the SWAT+ projects' text input files

### Link aquifers and channels with geomorphic flow

A SWATbuildR model setup only has one single aquifer (in its current version). This aquifer is linked with all channels through a channel- aquifer-link file (`aqu_cha.lin`) in order to maintain recharge from the aquifer into the channels using the geomorphic flow option of SWAT+ The required input file cannot be written with the SWAT+Editor. Therefore it has to be generated in a step after writing the model text input files with the SWAT+Editor.

Path of the TxtInOut folder (project folder where the SWAT+ text files are written with the SWAT+Editor)

```{r, txtpath}
txt_path <- '../swat_runs/txtinouit/'
```

```{r, linkaqui}
#link_aquifer_channels(txt_path)
```
